7.1 
-클래스 멤버 변수 설계: 캡슐화를 통한 간접 접근
	클래스의 멤버 변수는 외부에서 직접 접근이 안되도록 숨기고 멤버 함수를 통해서만 접근을 허용하도록 
	설계
	이를 통해 객체 상태를 안전하게 보호하면서 클래스의 유지보수성을 높일 수 있음

-객체의 사이클 관리 
	생성자를 통해 객체가 생성될 때 객체의 데이터 멤버를 초기화
	소멸자를 통해 객체가 사용하는 데이터 멤버의 자원을 회수
	
	복사를 통하여 새로운 객체를 생성하는 경우 원본과 동일한 상태의 새로운 독립적 객체 생성 하지만 일반적인 복사의 경우 내부 데이터 멤버를 그대로 복사하여 포인터의 경우 동일한 주소가 그대로 복사가 됨
	Sales_data item1;       // item1의 생명주기 시작
	Sales_data item2 = item1; // '복사' 발생. item2라는 새로운 객체의 생명주기가 시작됨.
	
	할당은 객체의 생명주기 동안 이미 존재하는 객체의 상태가 바뀌는 것으로 복사 할당 연산자에 의해 처리되며 새로운 객체 생성 X
	Sales_data item1, item2; // item1과 item2의 생명주기가 이미 시작됨
	item1 = item2;           // '할당' 발생. item1의 내용이 item2의 내용으로 수정됨.

-비멤버 함수(Nonmember Class-Related Functions)
	클래스의 멤버는 아니지만, 개념적으로 클래스 인터페이스의 일부를 구성하는 외부 함수.
	입출력(cout << total)이나 두 객체 간의 대칭적인 연산(item1 + item2)처럼 멤버 함수보다 외부 함수로 구현하는 경우 사용되며 이 함수들은 클래스와 동일한 헤더 파일에 함께 선언되어야 하고 private 멤버에 접근해야 	할 경우 클래스 내에서 friend로 선언.
	
7.2
-접근 지정자 (public, private)
	public: 클래스 외부 어디서든 접근할 수 있는 인터페이스.
	private: 클래스 내부 멤버 함수나 friend에서만 접근할 수 있는 구현 영역.
	+접근 제어는 컴파일 타임에만 유효한 문법적 장치로, 런타임 성능에 전혀 영향을 주지 않습니다.

-class와 struct에서의 접근
	c++에서 두 키워드의 유일한 차이점은 기본 접근 수준입니다. class는 private, struct는 public이 기본값입니다.
	```cpp
	class MyClass {
	    int x; // 접근 지정자가 없으므로 기본값인 private
	public:
	    int y; // public으로 명시했으므로 외부 접근 가능
	};
	
	struct MyStruct {
	    int x; // 접근 지정자가 없으므로 기본값인 public
	private:
	    int y; // private으로 명시했으므로 외부 접근 불가
	};
	```

-friend 선언 (Friend Declaration)
	특정 외부 함수나 다른 클래스에게 private 멤버에 대한 접근 권한을 부여하는 기능입니다.
	주의: friend의 경우 해당 클래스의 캡슐화를 약화시킴(해당 클래스의 멤버함수 외 함수에서 해당 클래스에 접근이 많아짐 ), 꼭 필요한 경우가 아니라면 남용X.
	
7.3
-타입 멤버 (using, typedef)
	클래스 내에서 타입 별칭을 새로 정의하는 기능 다른 멤버들과 종일한 접근 제어 규칙 적용
	```cpp 
	class MyClass{
		public:
		typedef unsigbed int SIZE;
		using BYTE = unsigned char;
		...
	};
	타입 멤버를 사용하면, 사용자는 Screen::pos와 같이 간단하고 의미 있는 이름으로 해당 타입에 접근가능
	

-명시적 inline 멤버 함수
	클래스 본문 내부에 정의된 함수는 암시적으로 inline이 되며, inline 키워드를 사용해 명시적 지정.
	inline 함수의 정의(구현)는 반드시 헤더 파일(.h)에 위치.

-mutable 데이터 멤버
	mutable로 선언된 데이터 멤버는 const 멤버 함수 내에서도 예외적으로 값을 수정 가능.
	const 멤버 함수는 객체의 상태를 변경하지 않겠다고 약속하는 함수 but mutable 멤버는 이 약속에서 제외
```cpp
	class display{
	public:
	    void DisplayShow() const;
	private:
	    mutable size_t frameCnt; 
	    
	};
	
	void Screen::some_member() const {
	    ++frameCnt; // OK
	}
```


-*this 반환과 메서드 체이닝
	멤버 함수가 객체 자신의 참조(*this)를 반환하게 하면, myScreen.move(4,0).set('#');처럼 여러 연산을연속적으로 호출(chaining)할 수 있습니다.
	myScreen.move(4,0).set('#');// myScreen.move(4,0) 가 (*this) 를 반환

-클래스 타입과 전방 선언 (Class Types and Forward Declarations)
	class 또는 struct 키워드로 정의된 모든 것은 C++에서 고유한 타입으로 멤버의 종류나 개수가 완전히 동일하더라도, 이름이 다른 두 클래스는 서로 다른 타입으로 취급
	
	전방선언 이란 클래스를 완전히 정의하지 않고 이름만 먼저 컴파일러에게 알려주는 것으로 이렇게 선언된 
	클래스는 불환전 타임으로 객체 생성은 X , 포인터나 참조 선언은 가능 A 헤더의 a 클래스에 B헤더의 b의 포인터를 B의 헤더에서도 B클래스가 a클래스의 포인터를 가지는 경우 헤더에 서로 include 하는 문제가 	발생 해당경우 컴파일 에러 발생 전방선언을 통해 A 와 B에 a , b를 만든 다음 A.cpp B.cpp 에서 	include 하여 문제를 해결할 수 있음 

-Friendship Revisited
	friend는 비멤버 함수뿐만 아니라, 다른 클래스 전체 또는 다른 클래스의 특정 멤버 함수에게도 사용이 가능
	
	friend 클래스: friend class Window_mgr; 처럼 선언하면, Window_mgr의 모든 멤버 함수가 private 멤버에 접근 가능.

	friend 멤버 함수: friend void Window_mgr::clear(); 처럼 다른 클래스의 특정 멤버 함수 하나에게만 friend 권한을 부여 가능.


7.4
-클래스 범위 내 이름 조회 방식
	1) 멤버 선언 컴파일 
	컴파일러는 클래스 정의를 처음 읽을 때, 멤버 함수의 본문({} 내부 코드)은 건너뛰고 클래스 내에 있는 모든 	데이터 멤버와 멤버 함수의 선언부(이름, 반환 타입, 매개변수 등)를 먼저 수집
	
	2) 멤버 함수 본문 컴파일 (정의부 해석)
	1단계에서 클래스의 전체 멤버 목록을 파악한 후, 컴파일러는 두 번째 단계로 각 멤버 함수의 본문 컴파일	
	이를 통해 함수 본문을 컴파일하는 시점에는 이미 클래스의 모든 멤버 선언을 알고 있어 자신보다 뒤에 선언된 다른 멤버를 자유롭게 사용 가능
```cpp
	class Example {
	public:
	    void func1() {
	        // 2단계에서 컴파일될 때, 컴파일러는 이미 func2()와 data_의 존재를 알고 있음
	        data_ = 10; // func1보다 뒤에 선언된 data_ 사용
	        func2();    // func1보다 뒤에 선언된 func2() 호출
	    }
	
	private:
	    int data_;
	    void func2() { /* ... */ }
	};
```
	이름 탐색 순서의 경우 멤버 함수 본문에서 사용된 이름은 멤버 함수 지역 스코프(지역변수) →클래스 전체 스코프(멤버 변수 , 멤버 함수) → 외부 스코프(전역 변수 , 전역 함수 , 다른 클래스 ..등등) 순으로 탐색


7.5
-Constructor Initializer List
	멤버 변수가 생성 되는 시점에 초기화하는 방식으로 멤버 변수의 메모리가 할당 될때 주어진 값으로 변수 생성하는 방식	
```cpp
	class MyClass {
	    std::string str_member;
	public:
	    //Constructor Initializer List
	    MyClass(const char* s) : str_member(s) {}
	
	    //본문 내 할당
	    MyClass(const char* s) { str_member = s; }
	};
```
	Constructor Initializer List 방식의 경우 str_member가 생성될 때 std::string의 const char*를 받는 생성자가 한 번만 호출되어 바로 초기화됩니다. 
	기존의 본문 내에서 초기화시 먼저 str_member는 기본 생성자에 의해 빈 문자열 로 초기화 됨 이후 멤버 변수에 할당하는 방식의 경우 생성자 본문이 실행되며 할당연산자가 호출되어 값을 할당 합니다.
	
```cpp
	class BadExample {
	    int i;
	    int j;
	public:
	    // 의도: val -> j -> i 순서로 초기화
	    // 실제 동작: 선언 순서에 따라 i가 먼저 초기화되고, 그 다음 j가 초기화됨
	    BadExample(int val) : j(val), i(j) {
	        // 이 시점에 i는 초기화되지 않은 j의 '쓰레기 값'으로 초기화된 상태!
	    }
	};
```
	멤버는 초기자 리스트에 나열된 순서가 아니라, 클래스에 멤버가 선언된 순서대로 초기화함 이경우 i(j) 가 j(val) 보다 더 먼저 이루어져 i는 쓰레기 값으로 초기화됨


-위임 생성자 (Delegating Constructors)
	한 생성자가 다른 생성자를 호출하여 초기화 작업을 위임함 .
```cpp
class Sales_data {
public:
    // 타겟 생성자
    Sales_data(std::string s, unsigned cnt, double price):
        bookNo(s), units_sold(cnt), revenue(cnt*price) { }

    // 아래 생성자들은 타겟 생성자에게 초기화를 위임함
    Sales_data() : Sales_data("", 0, 0) {}
    Sales_data(std::string s) : Sales_data(s, 0, 0) {}
};
```

-explicit과 암시적 변환 (Implicit Conversion & explicit)
	인자가 하나인 생성자는 암시적 변환 생성자로 작용할 수 있음 explicit 키워드는 이러한 의도치 않은 자동 변환을 막아 코드의 명확성을 높일 수 있음.
```cpp
class Sales_data {
public:
    explicit Sales_data(const std::string &s);
    // ...
};

void process(Sales_data item);

// process("978-0321714114"); // 에러: string 생성자는 explicit이므로 암시적 변환 불가
/*
변환 생성자는 다른 타입의 값을 클래스 타입 객체로 암시적으로 변환할 수 있는, 인자를 하나만 받는 생성자로 자동으로 객체를 생성 기능	
컴파일러가 타입이 맞지 않는 값을 발견하면 해당 인자로 클래스 객체를 만들 수 있는 변환 생성자를 찾아 임시 객체 생성 후 연산 수행 => 의도하지 않은 변환이 문제가 될 수 있음
*/
process(Sales_data("978-0321714114")); // OK: 명시적으로 객체를 생성하여 전달

```
-집계 클래스 (Aggregate Classes)
	생성자 없이, 중괄호 {}를 이용해 멤버를 직접 초기화할 수 있는 단순한 데이터 묶음 클래스입니다. C언어의 struct와 유사(모든 멤버 변수 public)
	Data val1 = { 0, "Anna" };처럼 중괄호 리스트를 이용해 멤버 선언 순서대로 값을 초기화할때 사용
	
-리터럴 클래스 (Literal Classes)
	객체의 생성이 컴파일 타임에 이루어질 수 있는 특별한 종류의 클래스입니다. 리터럴 클래스의 객체는 constexpr로 선언되어 배열 크기 및 템플릿의 인자로 사용 가능
	모든 데이터 멤버가 리터럴 타입이어야 함
	최소 하나 이상의 constexpr 생성자(constexpr로 선언된 생성자는 모든 멤버를 상수 표현식을 통해 초기화)를 가져야 함
	클래스 내 멤버 초기값은 상수 표현식이어야 함
	소멸자가 기본 동작을 따라야 함(컴파일러가 자동으로 생성해주는 소멸자의 동작~MyClass() {} )
	
7.6
-static 멤버
	멤버는 특정 객체에 속하지 않고, 클래스 자체에 소속된 멤버입니다. 따라서 해당 클래스의 모든 객체가 공유하는 하나의 멤버 이때문에 static 멤버는 클래스의 모든 인스턴스에 걸쳐 공유되어야 하는 데이터나 기능에 사용
	
-static 멤버 변수
	클래스의 모든 객체가 공유하는 단 하나의 변수로 객체에 속하지 않으므로 객체 생성시 생성자에 의해 초기화X => 선언 과 정의 분리 
	선언의 경우 클래스 본문 내에서 static 키워드를 붙여 선언 
```cpp
class Account {
private:
    // interestRate를 static 멤버로 선언
    static double interestRate;
    // ...
};
```

	정의의 경우 static 키워드를 붙이지 않고, 스코프 결정 연산자(::)를 사용해 어떤 클래스의 멤버인지 명시함.
	 반드시 클래스 외부(보통 .cpp 파일)에서 단 한 번 정의되고 초기화되어함(안하면 컴파일은 성공하지만 링크 단계에서 unresolved external symbol라는 오류 발생).
```cpp
#include "Account.h"
// static 멤버를 외부에서 정의하고 초기화
double Account::interestRate = 0.025;
```

-static 함수
	특정 객체와 무관하게 동작하는 함수로 this 포인터를 가지지 않음 이때문에 static이 아닌 각객체의 멤버 변수에 접근이 불가능함 , 클래스에 속해있는 static 멤버만 접근가능 또한 const 의 경우 this 포인터가 가리키는 객체를 수정하지 않는 동작을 함으로 static 함수는 const 선언이 불가함

```cpp
// Calculator.h
class Calculator {
public:
    // static 멤버 함수 'add'를 선언
    static int add(int a, int b);
};

// static 멤버 함수 'add'를 정의 (static 키워드 없음!)
int Calculator::add(int a, int b) {
    return a + b;
}

// 객체 생성 없이 static 멤버 함수 호출
int result = Calculator::add(5, 3);
 ```
