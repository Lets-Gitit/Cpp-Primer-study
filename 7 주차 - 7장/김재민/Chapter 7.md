# Chapter 7

---

## [ 추상화 ]

**공통적인 속성과 행위를 추출하여 불필요한 세부 사항을 숨기고 간결하게 모델링하는 과정입니다.**

- 공통 특징 ( 속성, 기능 등 ) 을 추출하여 클래스로 표현하는 작업입니다.
    - 자동차 → 이동한다, 속도 ( 공통 개념 )

---

## [ 가상 함수 ]

- 부모 클래스의 포인터나 참조를 통해 자식 클래스에서 재정의된 함수를 호출할 수 있게 해주는 멤버 함수입니다.
- 이를 통해서 다형성을 구현할 수 있습니다.

**예시**

- 도형이라는 명령으로 도형을 생성한다고 해봅시다
    
    ```cpp
    Shape* shape;
    shape = new Circle();
    shape -> draw();     // 동그라미 그리기
    
    shape = new Rectangle();
    shape -> draw();     // 직사각형 그리기
    ```
    
    - Shape라는 포인터가 어떤 객체를 가르키는지에 따라 다른 결과를 내놓습니다.  ( → 이것이 다형성의 핵심 )

**정적 바인딩**

- 컴파일러가 shape가 Shape*인걸 보고 무조건 적으로 Shape클래스의 draw() 메서들 호출하는 것

**동적 바인딩**

- 컴파일러가 이 함수는 실행될 때 실제 객체 타입을 보고 결정하겠다 판단하는 것입니다.

**컴파일러의 처리 과정**

1. 가상 함수 테이블 ( vtable )
    - 클래스 단위로 생성됩니다.
    - 가상 함수를 하나라도 가진 클래스는 컴파일 타임에 자신만의 vtable을 갖게 됩니다.
    - vtable은 가상 함수들의 실제 메모리 주소를 담고 있는 배열입니다.
    - 자식 클래스가 가상 함수를 override 하면, 자식 클래스의 vtable에는 재정의된 함수의 주소가 대신 저장됩니다.
2. 가상 함수 포인터 ( vptr )
    - 객체 단위로 생성됩니다.
    - 가상 함수를 가진 클래스로부터 객체가 생성될 때, 해당 객체의 메모리 공간 맨 앞에 숨겨진 포인터인 vptr이 추가됩니다.
    - 이 vptr은 자신이 속한 클래스의 vtable을 가리킵니다.

```cpp
동작 과정

1. Shape* shape = new Circle(); 코드가 실행되면, Circle 객체가 메모리에 생성됩니다.
	 이때 Circle 객체 내의 vptr은 Circle클래스의 vtable을 가리키로독 설정됩니다. 

2. Shape->draw(); 코드가 실행되면, 프로그램은 다음 순서로 동작합니다.
		1) Shape 포인터가 가리키는 객체(Circle)로 접근합니다. 
		2) 객체 안에 숨겨진 vptr을 읽어 Circle의 vtable 주소를 찾아냅니다. 
		3) vtable에서 draw() 함수에 해당하는 주소를 찾습니다. 
		4) 그 주소에 있는 함수, 즉 Circle::draw()를 호출합니다. 
```

---

## [ 생성자 ]

- **초기화 때부터 객체의 상태는 유효해야 합니다.**
- **객체를 선언할 때 필요한 모든 의존성을 명확하게 드러내고, 외부에서 입력받아야 합니다.**

**의존성이 숨겨진 경우**

```cpp
class Car {
private:
    Engine engine; // 자동차가 직접 엔진을 생성 (강한 결합)
    Tire tire;     // 자동차가 직접 타이어를 생성 (강한 결합)

public:
    // 기본 생성자
    Car() {
        this->engine = new V8_Engine(); // 어떤 엔진을 쓰는지 내부에서 결정
        this->tire = new SportTire();   // 어떤 타이어를 쓰는지 내부에서 결정
    }
    void go() { /* ... */ }
};

// 사용하는 쪽에서는 Car가 어떤 부품을 필요로 하는지 알 수 없다.
Car myCar = new Car();
```

- 문제점
    - Car 객체를 만들기 위해 어떤 종류의 Engine이나 Tire가 필요한지 밖에서는 전혀 알 수 없습니다.
    - 내부 코드를 봐야만 알 수 있으며, 엔진을 ElectricEngine으로 바꾸려면 Car 클래스 자체를 수정해야 합니다. 또는 Getter, Setter를 만들어 수정해야 합니다.
    - 이로 인해 테스트가 복잡해집니다.

**외부에서 입력 받는 경우**

```cpp
class Car {
private:
    Engine& engine; // 외부에서 생성된 엔진을 참조
    Tire& tire;     // 외부에서 생성된 타이어를 참조

public:
    // 생성자를 통해 의존성을 외부에서 주입(Injection)받음
    Car(Engine& eng, Tire& t) : engine(eng), tire(t) {}

    void go() { /* ... */ }
};

// 사용하는 쪽에서 필요한 부품을 직접 준비해서 전달해야 한다.
V8_Engine myEngine = new V8_Engine();
SportTire myTire = new SportTire();
Car myCar = new Car(myEngine, myTire); // 아! 자동차를 만들려면 엔진과 타이어가 필요하구나!
```

- 장점
    - Car 클래스의 생성자만 봐도 자동차를 만들려면 엔진과 타이어가 필요하다는 것을 바로 알 수 있습니다.

**의존성을 드러내는 것이 중요한 이유**

1. 객체의 책임과 관계가 명확해집니다. 
    - 생성자의 매개변수 목록은 그 객체의 협력자 목록이 됩니다.
    - 객체의 책임과 역할을 파악하기 쉬워집니다.
2. 느슨한 결합
    - Car는 V8_engine 에 직접 의존하지 않고, 추상적인 Engine에 의존합니다.
    - 덕분에 쉽게 교체할 수 있고, 유연하고 확장성 있는 코드가 됩니다.
3. 테스트의 용이성
    - Car 객체를 독립적으로 테스트할 수 있습니다.

---

## [ 접근 제어 ]

**객체의 내부 데이터를 보호하고 의도치 않은 수정을 방지하며, 클래스를 올바르게 사용하도록 유도하는 캡슐화를 달성하는 것을 의미합니다.** 

| 키워드 | 클래스 내부 | 자식 클래스 | 외부 |
| --- | --- | --- | --- |
| public | 0 | 0 | 0 |
| protected | 0 | 0 | x |
| private | 0 | x | x |

- Getter & Setter
    - private 멤버 변수마다 Getter와 Setter를 만드는 것은 캡슐화를 해칩니다.
    - 이는 변수를 public으로 만드는 것과 차이가 없습니다.
    - Setter
        - 반드시 유효성 검사를 포함시켜야 합니다.
            
            ```cpp
            // GOOD: 유효성 검사를 통해 데이터 무결성을 지킨다.
            void setLevel(int newLevel) {
                if (newLevel > 0 && newLevel < 100) {
                    this->level = newLevel;
                }
            }
            ```
            
    - Getter
        - 이 정보를 정말 외부에 알려줘야 하는지 고민해야 합니다.
        - 그 정보를 이용해 특정 동작을 하는 함수를 public으로 제공하는 것이 더 객체지향적일 수 있습니다.

---

## [ friend 키워드 ]

**다른 클래스에게 자신의 private 및 protected 멤버에 접근할 수 있는 특별한 권한을 부여할 때 사용합니다**.

**동작 원리**

- friend는 클래스가 선언하는 것입니다.
- A가 B를 친구로 선언해도, B가 A의 친구가 되는 것이 아닙니다.
    - 즉 B 는 A의 private 변수에 접근 가능
    - A는 B의 private 변수에 접근할 수 없습니다.

---

## [ Gettter, Setter VS friend ]

**G / Setter 는 클래스의 공식적인 통로를 제공해 데이터를 제어하는 정문**

**friend는 특정 협력자에게만 내부로 통하는 비밀열쇠 제공**

### G / Setter 사용할 때

- 클래스의 데이터를 보호하면서 외부에 안전한 소통 창구를 열어둘 때 사용합니다.
1. 데이터를 변경하기 전에 반드시 유효성 검사를 해야할 때
    - 객체의 상태가 유효한 범위 내에 있도록 보장합니다.
    - Setter의 가장 중요한 존재 이유입니다.
        
        ```cpp
        class User {
        private:
            int m_age;
        public:
            void setAge(int age) {
                if (age > 0 && age < 150) { // 나이는 0보다 크고 150보다 작아야 한다는 규칙 적용
                    m_age = age;
                }
            }
        };
        ```
        
2. 외부에 값을 읽기 전용으로만 제공하고 싶을 때
    - 데이터를 수정할 수는 없지만, 현재 상태 값을 알려줄 필요가 있을 때 사용합니다.
- 결론
    - 일반적인 외부 사용자가 객체의 데이터에 접근해야 한다면 무조건 G / Setter를 고려해야 합니다.

**friend를 사용해야할 때** 

- 기술적인 제약이나 설계상의 이유로 멤버 함수가 될 수는 없지만, 개념적으로는 클래스의 일부처럼 동작해야 하는 매우 밀접한 협력자에게 제공할 때 사용합니다.
1. 연산자 오버로딩
    - operator << 는 ostream 클래스의 멤버를 수정할 수 없으므로 가장 대표적이고 정당한 사용 사례입니다.
        
        ```cpp
        class Vector2D {
            friend std::ostream& operator<<(std::ostream& out, const Vector2D& v);
        private:
            float m_x, m_y;
        };
        // 이 함수는 Vector2D의 일부처럼 동작해야 한다.
        std::ostream& operator<<(std::ostream& out, const Vector2D& v) {
            out << "(" << v.m_x << ", " << v.m_y << ")"; // m_x, m_y에 직접 접근
            return out;
        }
        ```
        
2. 두 클래스가 하나의 단위처럼 동작해야할 때
    - Matrix와 Vector 클래스가 서로 곱셈 연산을 할 때
    - Getter 호출보다 훨씬 효율적이고 코드가 깔끔합니다.

---

## [ mutable 키워드 ]

**멤버 변수 안에서 예외적으로 수정을 허용하고 싶은 멤버 변수에 사용하는 키워드입니다**.

### 비트단위 상수성 ( Bitwise Constness )

- const 멤버 함수 내에서는 객체를 구성하는 메모리의 어떤 비트도 변경할 수 없다는 의미입니다.

### 논리적 상수성 ( Logical Constness )

- const 멤버 함수를 호출해도 그 객체의 외부에서 관창 가능한 상태는 변하지 않는다는 의미입니다.

### 정의

- 클래스나 구조체의 데이터 멤버에만 적용할 수 있습니다.
- static, const, reference 멤버에는 적용되지 않습니다.
- 이 키워드가 붙은 변수는 mutable멤버로 취급됩니다.
- 객체가 const로 선언되었거나 const 멤버 함수 내에서 호출되더라고 값을 변경할 수 있습니다.

### 왜 필요한가?

- cosnt 멤버 함수는 객체의 상태를 변경하지 않아야 합니다.
- 하지만 때로는 논리적으로 객체의 상태를 변경하지 않으면서도 내부적으로 데이터를 수정해야 할 때가 있습니다.
- mutable은 이런 경우에 사용합니다.