## **1. 선언과 정의, 그리고 유효 범위(Scope)의 함정**

- **`if`, `for`문의 조건부 변수 선언:** `if (int val = some_func())` 와 같은 문법은 편리하지만, `val` 변수의 생명주기를 정확히 이해해야 합니다.
    - **심화 개념:** 이 변수는 `if-else if-else` 블록 전체에서 유효합니다. 즉, `else` 블록 안에서도 `val`에 접근할 수 있습니다.
    - **헷갈리는 점:** `if` 조건문에서 선언했는데 `else`에서도 쓸 수 있다는 점이 직관적이지 않을 수 있습니다. 이 변수는 `if`문을 벗어나는 순간 소멸됩니다.
        
        `cppif (int val = some_func()) {
            *// val은 0이 아닌 값*
        } else {
            *// val은 여기서도 유효하며, 값은 항상 0이다.*
        }
        *// 이 지점에서는 val 사용 불가 (소멸됨)*`
        
- **`switch` 문과 변수 선언의 충돌:** `switch`문 내부의 `case` 레이블은 점프 지점일 뿐, 독립적인 유효 범위를 만들지 않습니다.
    - **심화 개념:** 특정 `case`에서 변수를 **초기화**하면, 그 `case`를 건너뛰고 다른 `case`로 점프했을 때 해당 변수는 '선언은 되었지만 초기화되지 않은' 위험한 상태가 될 수 있습니다. C++는 이를 막기 위해 컴파일 에러를 발생시킵니다.
    - **해결책:** `case` 내에서 변수를 선언하고 싶다면, 반드시 중괄호 `{}`를 사용해 독립적인 블록(유효 범위)을 만들어야 합니다.
        
        `cppcase 1: { *// 블록을 만들어 변수의 생명주기를 제한*
            std::string s = "hello";
            *// ... s를 사용 ...*
            break;
        } *// s는 여기서 소멸*
        case 2:
            *// s 사용 불가*
            break;`
        

---

## **2. 반복문의 미묘한 차이와 최적화**

- **범위 기반 `for`문과 복사 비용:** 범위 기반 `for`문은 매우 편리하지만, 내부 동작을 모르면 성능 저하를 유발할 수 있습니다.
    - **심화 개념:** `for (auto x : my_vector)`는 `my_vector`의 모든 요소를 `x`로 **복사**합니다. 만약 `my_vector`의 요소가 크기가 큰 객체라면, 매 반복마다 불필요한 복사 생성과 소멸이 일어납니다.
    - **최적화:**
        1. **값 수정이 필요 없다면 `const auto&`를 사용:** `for (const auto &item : my_vector)`는 불필요한 복사를 막고, 원본 데이터를 실수로 변경하는 것도 방지합니다.
        2. **값 수정이 필요하다면 `auto&`를 사용:** `for (auto &item : my_vector)`는 복사 없이 원본에 직접 접근하여 값을 수정합니다.
- **전통적 `for`문 vs. `while`문:** 기능적으로는 서로 변환 가능하지만, **의도**를 명확히 드러내는 데 차이가 있습니다.
    - **`for`문이 적합할 때:** 반복 횟수가 명확하거나, 특정 범위를 순회하거나, 논리적으로 연관된 초기화/조건/증감 식이 있을 때 (가독성 향상)
    - **`while`문이 적합할 때:** 특정 조건이 만족될 때까지(예: 파일 끝에 도달할 때까지, 사용자가 특정 값을 입력할 때까지) 반복해야 할 때. 즉, 반복 횟수를 예측하기 어려울 때.

---

## **3. `switch` 문의 Fall-Through와 의도적 사용**

- **`break` 생략의 위험성:** `break`를 실수로 빠뜨리는 것은 흔한 버그의 원인입니다. `case 'a':`가 실행된 후 `break`가 없으면 `case 'e':` 코드가 연달아 실행됩니다.
- **의도적인 Fall-Through:** 하지만 때로는 이것이 유용한 기법이 될 수 있습니다. 여러 `case`가 동일한 동작을 할 때 코드를 중복 작성하지 않아도 됩니다.
    
    `cppswitch (key) {
        case 'h': *// 왼쪽*
        case 'a':
            x--;
            break;
        case 'l': *// 오른쪽*
        case 'd':
            x++;
            break;
    }`
    
    - **C++17 이상:** 의도적인 fall-through임을 명시하여 컴파일러 경고를 없애고 다른 개발자에게 의도를 명확히 알리는 `[[fallthrough]]` 속성이 추가되었습니다.

---

## **4. 예외 처리의 깊은 이해: RAII와 예외 안전성**

- **`try-catch`는 만능이 아니다:** 예외 처리는 단순히 프로그램을 죽지 않게 하는 것 이상을 의미합니다.
- **RAII (Resource Acquisition Is Initialization, 자원 획득은 초기화다):** C++의 가장 중요한 개념 중 하나입니다. 파일 핸들, 메모리, 락(lock) 같은 자원을 객체의 생성자에서 획득하고 **소멸자에서 해제**하는 기법입니다.
    - **심화 개념:** `try` 블록에서 예외가 발생하면, 해당 블록의 나머지 코드는 실행되지 않고 바로 `catch`로 점프합니다. 만약 자원을 수동으로 해제하는 코드가 `try` 블록 끝에 있다면 그 코드는 실행되지 않아 **자원 누수(resource leak)**가 발생합니다.
    - **RAII의 위대함:** RAII 객체(스마트 포인터 `unique_ptr` 등)를 사용하면, 예외가 발생하여 정상적인 흐름을 벗어나도 스택이 풀리면서(stack unwinding) 해당 객체의 **소멸자가 반드시 호출**되는 것을 언어가 보장합니다. 따라서 소멸자에서 자원을 해제하면 자원 누수를 원천적으로 방지할 수 있습니다.
- **예외 안전성 (Exception Safety):** 예외가 발생했을 때 프로그램이 안전하고 일관된 상태를 유지하는 것을 의미합니다.
    - **기본 보장 (Basic Guarantee):** 예외가 발생하더라도 자원 누수가 없고, 모든 객체는 여전히 유효한(파괴 가능한) 상태를 유지합니다. (RAII를 잘 활용하면 달성)
    - **강력 보장 (Strong Guarantee):** 예외가 발생하면, 연산이 시작되기 전의 상태로 모든 것을 되돌립니다. (마치 연산이 아예 없었던 것처럼)
    - **무 예외 보장 (No-throw Guarantee):** 함수가 절대로 예외를 던지지 않음을 보장합니다. (`noexcept` 키워드)
