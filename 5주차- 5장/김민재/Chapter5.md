Chapter 5: Statements and Flow of Control

5.1. Simple Statements (단순 문장)
- 대부분의 C++ 문장은 세미콜론(;)으로 끝남.
- 표현식 뒤에 세미콜론을 붙이면 표현식 문장이 되며, 계산 결과는 버려질 수 있음.
- 부작용이 있는 표현식(예: 출력, 대입 등)은 유용한 문장이 됨.
Null Statement (널 문장)
- 단순히 세미콜론 하나만 있는 문장.
- 문법적으로 문장이 필요하지만 실제 작업이 필요 없는 경우 사용.
- 루프 조건만으로 작업을 수행할 때 자주 사용됨.
- 반드시 주석을 달아 의도적인 생략임을 명시하는 것이 좋음.
Compound Statement (복합 문장 / 블록)
- 중괄호 {}로 둘러싸인 여러 문장.
- 하나의 문장처럼 취급되며, **스코프(scope)**를 형성함.
- 루프나 조건문에서 여러 문장을 실행하고 싶을 때 사용.
주의사항
- 불필요한 세미콜론은 종종 무해하지만, 조건문 뒤에 붙으면 의도와 다르게 동작할 수 있음.
- 들여쓰기와 실제 실행 흐름이 다를 수 있으므로 중괄호 사용을 권장함.

5.2. Statement Scope (문장의 범위)
- 제어문(if, while, for, switch)의 조건부에서 선언된 변수는 해당 문장 내에서만 유효.
- 루프나 조건문 외부에서 변수에 접근하려면 블록 밖에서 선언해야 함.
- 조건부에서 선언된 변수는 반드시 초기화되어야 하며, 해당 제어문에서만 사용됨.

5.3. Conditional Statements (조건문)
if 문
- 조건에 따라 코드 실행을 분기.
- if와 if–else 두 가지 형태가 있음.
- 조건은 반드시 괄호로 감싸야 하며, bool로 변환 가능한 타입이어야 함.
Dangling else (매달린 else 문제)
- 중첩된 if 문에서 else가 어느 if에 속하는지 모호할 수 있음.
- C++에서는 가장 가까운 매칭되지 않은 if에 else가 연결됨.
- 중괄호를 사용하여 의도를 명확히 표현하는 것이 중요함.
주의사항
- 중괄호를 생략하면 의도와 다르게 동작할 수 있음.
- 들여쓰기와 실행 흐름이 다를 수 있으므로 항상 중괄호를 사용하는 것이 안전함.

5.3.2. switch Statement (switch 문)
- 정수형 표현식을 평가하여 여러 경우 중 하나를 선택.
- 각 case는 고유한 정수 상수여야 하며, 중복되면 오류 발생.
- default는 어떤 case에도 해당하지 않을 때 실행됨.
흐름 제어
- break를 생략하면 다음 case로 실행이 이어지는 fall-through 발생.
- 여러 case가 같은 동작을 할 때는 break 없이 묶을 수 있음.
변수 정의 주의
- switch 문 내에서 초기화된 변수를 건너뛰는 경우는 불법.
- 변수는 블록 내부에서 정의하여 스코프를 제한해야 함.
Best Practice
- 마지막 case에도 break를 넣는 것이 안전함.
- fall-through가 의도된 경우에는 반드시 주석으로 설명할 것.

5.4. Iterative Statements (반복문)
while 문
- 조건이 참인 동안 반복 실행.
- 조건이 처음부터 거짓이면 본문은 실행되지 않음.
- 루프 내에서 조건을 변경하지 않으면 무한 루프 발생 가능.
for 문
- 초기화, 조건, 증감식을 포함한 반복 구조.
- 세 부분 중 일부 또는 전부 생략 가능.
- 조건 생략 시 항상 참으로 간주되므로 루프 내부에서 종료 조건 필요.
range for 문
- 컨테이너의 모든 요소를 순회하는 간단한 문법.
- auto와 참조(&)를 사용하면 타입 추론과 값 수정이 가능.
- 내부적으로는 전통적인 for 문으로 변환됨.
- 컨테이너를 수정하면 end()가 무효화될 수 있으므로 주의.
do while 문
- 본문을 먼저 실행한 후 조건을 평가.
- 최소 한 번은 실행됨.
- 조건에 변수 선언 불가 → 변수는 루프 외부에서 선언해야 함.

5.5. Jump Statements (점프 문장)
break 문
- 가장 가까운 반복문 또는 switch 문을 종료.
- 중첩된 구조에서는 가장 가까운 블록만 종료함.
continue 문
- 현재 반복을 중단하고 다음 반복으로 즉시 이동.
- 루프 내부에서만 사용 가능.
- switch 문 안에서는 루프에 포함된 경우에만 사용 가능.
goto 문
- 무조건적인 점프를 수행.
- 같은 함수 내에서만 사용 가능.
- 초기화된 변수를 건너뛰는 점프는 불법.
- 가독성과 유지보수에 악영향 → 사용 지양.

5.6. try Blocks and Exception Handling (예외 처리)
예외란?
- 런타임 중 발생하는 비정상적인 상황.
- 예외 처리의 목적은 문제 감지와 처리 책임을 분리하는 것.
throw 표현식
- 예외를 발생시키는 키워드.
- 표현식의 타입이 예외의 종류를 결정함.
- 예외 발생 시 현재 함수는 종료되고, 적절한 catch 핸들러를 찾기 위한 탐색이 시작됨.
try–catch 구조
- try 블록 내부에서 예외가 발생하면, 가장 적절한 catch가 실행됨.
- catch가 끝나면 try 블록 이후의 코드로 흐름이 이어짐.
- what() 함수는 예외 메시지를 반환함.
예외 핸들러 탐색
- 예외가 발생하면 호출 스택을 역순으로 탐색.
- 핸들러가 없으면 terminate() 함수가 호출되어 프로그램 종료.
예외 안전성
- 예외 발생 시 자원 누수나 객체 불완전 상태 발생 가능.
- 예외 안전한 코드는 자원을 적절히 해제하고, 객체 상태를 유효하게 유지하며, 프로그램을 복구 가능한 상태로 되돌림.
- 예외 안전성 확보는 복잡하고 어려운 작업이며, 고급 기법이 필요함.

5.6.3. 표준 예외 클래스
| 헤더 파일 		| 예외 클래스 				| 특징 					| 
| <exception>	| exception 				| 가장 일반적인 예외. 메시지 없음 	| 
| <stdexcept> 	| runtime_error, logic_error 등 	| 문자열 메시지로 초기화 가능 	| 
| <new> 		| bad_alloc | 메모리 할당 실패 	| 						|
| <typeinfo> 	| bad_cast | 잘못된 형 변환 		| 						|


- 모든 예외 클래스는 what() 멤버 함수를 가짐.
- 반환값은 const char* 타입의 C 스타일 문자열.
- 메시지 내용은 예외 타입에 따라 다름.
