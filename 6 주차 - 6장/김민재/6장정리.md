-6.1 함수 기초

구성: 반환 타입 + 이름 + 매개변수 목록 + 본문.

호출: 인자가 매개변수를 초기화 → 본문 실행 → return으로 제어권/값 반환.

스코프/수명: 지역 이름은 블록 스코프, 객체 수명은 블록 종료 시 끝남.

인자 평가 순서 불명확: 여러 인자에 부작용 있는 표현식을 사용하지 말 것.

매개변수 이름/타입 별칭: 이름은 시그니처에 영향 없음, using/typedef는 새로운 타입이 아님.

정적 지역 객체(static): 최초 1회 초기화, 호출 간 값 유지, C++11 이후 초기화는 스레드 안전.

예시
```cpp
int fact(int v){ int r=1; while(v>1) r*=v--; return r; }

size_t count_calls(){
  static size_t ctr = 0;    // 호출 간 유지
  return ++ctr;
}
```


-6.2 인자 전달

값 전달: 복사본 생성, 원본 불변.

참조 전달: 별칭(aliased), 원본 수정 가능.

const 참조: 복사 비용 절감 + 리터럴/임시/변환 결과 수용, 원본 불변.

포인터/배열: 포인터는 값 전달(주소 복사), 배열은 함수 인자로 decay(크기 소실).

설계 원칙: 수정하지 않는 큰/복사불가 객체는 const T&로 받기.

배열 크기 관리: 마커(null), [beg,end), or 크기 매개변수 세 가지 패턴 중 하나를 명확히 선택.

다차원 배열: 두 번째 이후 차원은 타입의 일부 → 반드시 명시.

가변 인자: 동일 타입은 initializer_list<T>, 이질 타입은 템플릿(§1--6.4) 고려. ...는 C 호환 한정.

예시/안티패턴
```cpp
void reset(int &x){ x = 0; }           // 참조 버전
void reset(int *p){ *p = 0; }          // 포인터 버전

// 배열 인자 패턴
void print(const int* b, const int* e){ while(b!=e) std::cout<<*b++<<'\n'; }
void print(const int a[], size_t n){ for(size_t i=0;i<n;++i) std::cout<<a[i]<<'\n'; }
void print(int (&a)[10]){ for(auto v: a) std::cout<<v<<'\n'; } // 크기 안전(10에 고정)
```
체크리스트
불변 인자는 const&로, 변경 필요시 & 또는 *.

배열 전달 시 범위 정보를 반드시 함께 전달.

리터럴/임시/변환 결과를 받으려면 plain &가 아닌 const&.


-6.3 반환 타입과 return 문

형태: return;(void만) / return expr;(비void는 모든 경로에서 값 필수).

값 반환: 호출 지점의 임시로 초기화(복사/이동).

참조 반환: 원본 별칭(lvalue). const&는 읽기 전용.

로컬 객체 참조/포인터 반환 금지: dangling 참조/포인터.

제어 경로 누락: 루프 내 일부만 return하고 나머지 경로 미반환은 UB/컴파일 경고.

리스트 반환: 내장형은 원소 1개, narrowing 금지. 클래스형은 해당 타입의 규칙 따름.

main 예외: return 생략 시 0. EXIT_SUCCESS/FAILURE는 <cstdlib> 매크로(네임스페이스 접두사 없음).

재귀: 반드시 종료 조건. 상태 축소(invariant)에 근거해 증명 가능해야 안정적.

예시
```cpp
const std::string& shorter(const std::string& a, const std::string& b){
  return a.size() <= b.size() ? a : b; // 복사 없음, 안전
}
```

// lvalue 반환 활용
char& get_val(std::string& s, std::string::size_type i){ return s[i]; }
get_val(s,0) = 'A'; // s 수정



-6.4 오버로드된 함수

조건: 같은 이름, 다른 매개변수 목록(개수/타입/const 수식자 등).

반환 타입만 다름: 구분 불가(오류).

const 구분: top-level const는 구분 불가, low-level const(참조/포인터 대상)는 구분 가능.


스코프 우선: 내부 스코프 선언이 외부 오버로드 세트를 전부 가림(name lookup → type check).

API 설계: 캐스팅이 필요한 오버로드는 냄새. 파라미터 집합을 분리하거나 명명 구분 고려.

const_cast 활용 케이스: const 버전을 기반으로 비const 버전을 위임 구현(원본이 실제 비const일 때만 안전).

예시
```cpp
void print(const std::string&); 
void print(double);
void print(int);
// 같은 스코프에 두면 세 버전 모두 오버로드 세트로 매칭

// const 참조/참조로 구분
Record lookup(Account&), lookup(const Account&);

// const_cast 위임
std::string& shorter(std::string& a, std::string& b){
  const auto& r = shorter(static_cast<const std::string&>(a),
                          static_cast<const std::string&>(b));
  return const_cast<std::string&>(r);
}
```


-6.5 특정 용도를 위한 기능
기본 인자(Default Arguments)
규칙: 오른쪽부터 생략 가능, 한 스코프에서 한 번만 지정, 선언 시점 스코프에서 이름 해석, 호출 시점 평가.

설계: 기본값 사용 빈도가 낮은 인자를 왼쪽, 높은 인자를 오른쪽.

inline
목적: 호출 오버헤드 감소(짧고 자주 호출되는 순차 코드).

주의: 컴파일러가 무시할 수 있음. 정의는 보통 헤더에(ODR 일치 필요).

constexpr
요건: literal 타입 인자/반환, 본문은 상수로 평가 가능해야 함(단, 항상 상수 반환할 필요는 없음).

특성: 암묵적 inline, 인자가 상수 표현식이면 호출 결과도 상수 표현식.

디버깅 도구
assert: <cassert>, NDEBUG 정의 시 비활성.

진단 매크로: __func__, __FILE__, __LINE__, __DATE__, __TIME__.

예시
```cpp
using sz = std::string::size_type;
std::string screen(sz h=24, sz w=80, char bg=' ');

// constexpr 예
constexpr int new_sz(){ return 42; }
constexpr size_t scale(size_t n){ return new_sz() * n; }
int a[scale(2)]; // OK
```


-6.6 함수 일치(Overload Resolution)
단계
후보(candidate): 이름 동일, 선언 가시.

적합(viable): 인자 수 일치(기본 인자 포함), 각 인자가 매개변수로 변환 가능.

최적 일치(best): 인자별 변환 비용 비교.

변환 우선순위(높음→낮음)
정확 일치: 타입 동일, 배열/함수→포인터 decay, top-level const 추가/제거.

const 변환: low-level const 맞춤.

승격: char/short→int.

산술/포인터 변환: int↔double, 포인터 계열 등(서로 동등).

클래스 변환: 사용자 정의 변환.

모호성/안티패턴
작은 정수형 승격 함정: ff(int) vs ff(short) 호출에 'a'는 int로 승격 → ff(int).

동등 변환 두 개: manip(long) vs manip(float)에 3.14(double) → 모호.

예시
```cpp
void f(); void f(int); void f(int,int); void f(double,double=3.14);
f(5.6);           // f(double,double) 선택(정확 일치 + 기본 인자)
f(42, 2.56);      // f(int,int) vs f(double,double) → 모호(각 인자에서 서로 우위)
```


-6.7 포인터 함수(함수 포인터)

타입: 반환 타입과 매개변수 타입 목록으로 결정(이름은 타입에 불포함).

선언 문법: R (*pf)(Args...). 괄호 필수.

사용/오버로딩
대입/호출: 함수 이름은 자동으로 포인터로 decay, pf(args) 또는 (*pf)(args).

오버로드 선택: 포인터 타입이 정확히 일치하는 오버로드를 선택.

매개변수/반환으로 쓰기
매개변수: 함수 타입로 선언해도 자동 포인터 변환.

반환 타입: 자동 변환 없음 → 명시적으로 포인터 타입 표기 or trailing return.

선언 단순화
별칭/decltype: 함수 타입 vs 포인터 타입을 구분(포인터는 * 필요).

예시
```cpp
bool lengthCompare(const std::string&, const std::string&);
bool (*pf)(const std::string&, const std::string&) = lengthCompare;

void useBigger(const std::string&, const std::string&,
               bool (*cmp)(const std::string&, const std::string&));

using PF = int(*)(int*, int);
PF f1(int);                      // 함수 포인터 반환
auto f2(int) -> int(*)(int*,int);// trailing return
decltype(lengthCompare)* getFcn(const std::string&); // decltype은 함수 타입
```