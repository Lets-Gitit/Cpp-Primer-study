-6.1 함수 기초

구성: 반환 타입 + 이름 + 매개변수 목록 + 본문.

호출: 인자가 매개변수를 초기화 → 본문 실행 → return으로 제어권/값 반환.

스코프/수명: 지역 이름은 블록 스코프, 객체 수명은 블록 종료 시 끝남.

인자 평가 순서 불명확: 여러 인자에 부작용 있는 표현식을 사용하지 말 것.

매개변수 이름/타입 별칭: 이름은 시그니처에 영향 없음, using/typedef는 새로운 타입이 아님.

정적 지역 객체(static): 최초 1회 초기화, 호출 간 값 유지, C++11 이후 초기화는 스레드 안전.

예시
```cpp
int fact(int v){ int r=1; while(v>1) r*=v--; return r; }

size_t count_calls(){
  static size_t ctr = 0;    // 호출 간 유지
  return ++ctr;
}
```


-6.2 인자 전달

값 전달: 복사본 생성, 원본 불변.

참조 전달: 별칭(aliased), 원본 수정 가능.

const 참조: 복사 비용 절감 + 리터럴/임시/변환 결과 수용, 원본 불변.

포인터/배열: 포인터는 값 전달(주소 복사), 배열은 함수 인자로 decay(크기 소실).

설계 원칙: 수정하지 않는 큰/복사불가 객체는 const T&로 받기.

배열 크기 관리: 마커(null), [beg,end), or 크기 매개변수 세 가지 패턴 중 하나를 명확히 선택.

다차원 배열: 두 번째 이후 차원은 타입의 일부 → 반드시 명시.

가변 인자: 동일 타입은 initializer_list<T>, 이질 타입은 템플릿(§1--6.4) 고려. ...는 C 호환 한정.
동일 타입


```cpp
#include <initializer_list>
#include <iostream>

void print_all(std::initializer_list<int> nums) {
    for (int n : nums) std::cout << n << " ";
}

int main() {
    print_all({1, 2, 3, 4}); // 모두 int
}
```

이질 타입
```cpp
#include <iostream>

template<typename... Args>
void print_all(Args... args) {
    (std::cout << ... << args) << "\n"; // fold expression
}

int main() {
    print_all(1, 3.14, "Hello"); // int, double, const char*
}

```

-6.3 반환 타입과 return 문

형태: return;(void만) / return expr;(비void는 모든 경로에서 값 필수).main 예외: return 생략 시 0.

값 반환: 호출 지점의 임시로 초기화(복사/이동).

참조 반환: 원본 별칭(lvalue). const&는 읽기 전용.

```cpp
#include <iostream>

int& get_element(int arr[], int index) {
    return arr[index]; // 원본 요소에 대한 참조 반환
}

int main() {
    int nums[3] = {1, 2, 3};
    get_element(nums, 1) = 42; // 원본 배열 요소를 직접 수정
    std::cout << nums[1] << "\n"; // 42 출력
}
```

```cpp
#include <iostream>
#include <string>

const std::string& get_name() {
    static std::string name = "민재";
    return name; // const 참조 반환
}

int main() {
    const std::string& ref = get_name();
    std::cout << ref << "\n"; // 읽기 가능
    // ref[0] = '김'; //  컴파일 에러: const 참조는 수정 불가
}
```

```cpp
int& bad_func() {
    int x = 10;
    return x; 
}
```

로컬 객체 참조/포인터 반환 금지: dangling 참조/포인터.

제어 경로 누락: 루프 내 일부만 return하고 나머지 경로 미반환은 UB/컴파일 경고.

리스트 반환: 내장형은 원소 1개, 클래스형은 해당 타입의 규칙 따름.

재귀: 반드시 종료 조건. 상태 축소(invariant)에 근거해 증명 가능해야 안정적.

예시
```cpp
const std::string& shorter(const std::string& a, const std::string& b){
  return a.size() <= b.size() ? a : b; // 복사 없음, 안전
}
```

// lvalue 반환 활용
char& get_val(std::string& s, std::string::size_type i){ return s[i]; }
get_val(s,0) = 'A'; // s 수정



-6.4 오버로드된 함수

조건: 같은 이름, 다른 매개변수 목록(개수/타입/const 수식자 등).

반환 타입만 다름: 구분 불가(오류).

const 구분: top-level const(객체 자체가 const)는 구분 불가, low-level const(참조나 포인터가 가리키는 대상이 const)는 구분 가능.
void f(int);        // #1
void f(const int);  // #2 → #1과 동일 시그니처, 중복 정의 에러

void f(int*);        // #1
void f(const int*);  // #2 → 서로 다른 타입, 오버로드 가능



스코프 우선: 내부 스코프 선언이 외부 오버로드 세트를 전부 가림(name lookup → type check).
#include <iostream>

void func(int)   { std::cout << "int\n"; }
void func(double){ std::cout << "double\n"; }

int main() {
    void func(char); // 내부 스코프 선언
    func(42);        // 외부 int/double 버전은 가려짐 → char 버전만 후보
}




-6.5 특정 용도를 위한 기능
기본 인자(Default Arguments)
규칙: 오른쪽부터 생략 가능, 한 스코프에서 한 번만 지정, 선언 시점 스코프에서 이름 해석, 호출 시점 평가.
void f(int a, int b = 10, int c = 20);
f(1);       // a=1, b=10, c=20
f(1, 2);    // a=1, b=2,  c=20

설계: 기본값 사용 빈도가 낮은 인자를 왼쪽, 높은 인자를 오른쪽.

inline
목적: 호출 오버헤드 감소(짧고 자주 호출되는 순차 코드).

주의: 컴파일러가 무시할 수 있음. 정의는 보통 헤더에(ODR 일치 필요).

constexpr
요건: literal 타입 인자/반환, 본문은 상수로 평가 가능해야 함(단, 항상 상수 반환할 필요는 없음).

특성: 암묵적 inline, 인자가 상수 표현식이면 호출 결과도 상수 표현식.

디버깅 도구
assert: <cassert>, NDEBUG 정의 시 비활성.

진단 매크로: __func__, __FILE__, __LINE__, __DATE__, __TIME__.

```cpp
#include <iostream>
#include <cassert>

void test() {
    std::cout << __func__ << " in " << __FILE__ << ":" << __LINE__ << "\n";
    assert(2 + 2 == 4);
}

int main() {
    test();
}
```


-6.6 함수 일치(Overload Resolution)
 C++ 컴파일러가 함수 오버로드 호출 시 어떤 함수를 선택하는지 에 대한 단계

후보(candidate): 이름 동일, 선언 가시.

적합(viable): 인자 수 일치(기본 인자 포함), 각 인자가 매개변수로 변환 가능.

최적 일치(best): 인자별 변환 비용 비교.

변환 우선순위(높음→낮음)
정확 일치: 타입 동일, 배열/함수→포인터 decay, top-level const 추가/제거.

const 변환: low-level const 맞춤.

승격: char/short→int.

산술/포인터 변환: int↔double, 포인터 계열 등(서로 동등).

클래스 변환: 사용자 정의 변환.

-6.7 포인터 함수(함수 포인터)

타입: 반환 타입과 매개변수 타입 목록으로 결정(이름은 타입에 불포함).

선언 문법: R (*pf)(Args...). 괄호 필수.

사용/오버로딩
대입/호출: 함수 이름은 자동으로 포인터로 decay, pf(args) 또는 (*pf)(args).

오버로드 선택: 포인터 타입이 정확히 일치하는 오버로드를 선택.

매개변수/반환으로 쓰기
매개변수: 함수 타입로 선언해도 자동 포인터 변환.

반환 타입: 자동 변환 없음 → 명시적으로 포인터 타입 표기 or trailing return.

선언 단순화
별칭/decltype: 함수 타입 vs 포인터 타입을 구분(포인터는 * 필요).

예시
```cpp
bool lengthCompare(const std::string&, const std::string&);
bool (*pf)(const std::string&, const std::string&) = lengthCompare;

void useBigger(const std::string&, const std::string&,
               bool (*cmp)(const std::string&, const std::string&));

using PF = int(*)(int*, int);
PF f1(int);                      // 함수 포인터 반환
auto f2(int) -> int(*)(int*,int);// trailing return
decltype(lengthCompare)* getFcn(const std::string&); // decltype은 함수 타입
```

함수 포인터에 대한 추가 학습
핵심 개념
- 정의: 함수 포인터는 “특정 함수 시그니처를 가진 함수의 주소”를 담는 포인터다. 이름만 쓰면 함수는 자동으로 포인터로 변환된다(decay).
- 시그니처 일치: 반환 타입, 매개변수 타입·순서, 호출 규약이 동일해야 같은 타입의 함수 포인터에 담을 수 있다.
- 호출 방법: 저장한 포인터로 p(args) 또는 (*p)(args)처럼 호출할 수 있다. 둘은 동일하게 동작한다.

선언과 호출 패턴
- 자유 함수 포인터 선언
int add(int, int);
int (*pf)(int, int) = &add; // &는 선택 사항
std::cout << pf(2, 3);      // 5

- 별칭으로 가독성 향상
using BinOp = int(*)(int, int);
BinOp pf = add;

- 배열과 테이블 디스패치
int sub(int,int), mul(int,int), divi(int,int);
using Op = int(*)(int,int);
Op ops[] = { add, sub, mul, divi };
int r = ops[2](6, 7); // mul 호출 → 42

- 자동 타입 추론
- 기본: auto pf = add;로 선언하면 자동으로 “함수 포인터”로 추론된다.
- 템플릿 인자: 함수 템플릿 주소를 담으려면 구체적 인스턴스 타입이 결정되어야 한다.
- 기본 변환 규칙
- 함수 → 포인터: f와 &f는 동일한 주소로 취급된다.
- 배열/함수 디케이: 함수 이름은 표현식에서 포인터로 자동 변환되며, 포인터 산술은 허용되지 않는다.

오버로드와 형 선택
- 오버로드 주소 취득: 동일 이름의 여러 함수가 있을 때는 목적 시그니처를 명시해야 한다.
void g(int);
void g(double);
auto p1 = static_cast<void(*)(int)>(&g);    // 명시적 캐스트
void (*p2)(double) = g;                     // 선언 타입으로 선택

- 기본 인자와 무관: 기본 인자(default argument)는 타입의 일부가 아니므로 포인터 타입 결정에 영향이 없다.
- 템플릿 함수 포인터: 템플릿 함수는 타입이 정해져야 주소를 가져올 수 있다.
template<typename T> void h(T);
void (*ph)(int) = &h<int>; // OK
// void (*px)(int) = &h;   // 오류: 템플릿 인자 미정



멤버 함수 포인터
- 타입 차이: “자유 함수 포인터”와 “멤버 함수 포인터”는 완전히 다른 타입이며 호환되지 않는다.
- 선언과 호출
struct S { int fun(double); };
int (S::*pmf)(double) = &S::fun;   // 멤버 함수 포인터
S s;
int r = (s.*pmf)(3.14);            // 객체로 호출
S* ps = &s;
r = (ps->*pmf)(3.14);              // 포인터로 호출

- cv·ref 한정자와 오버로드: int fun(double) const & 같은 멤버 함수는 const/&가 타입에 포함되므로 포인터 타입도 이에 맞춰야 한다.
struct T { int f() const; };
int (T::*pmf)() const = &T::f; // const 일치 필요
- 데이터 멤버 포인터와 구분
struct U { int x; };
int U::* pmd = &U::x;     // 데이터 멤버 포인터
U u{};
u.*pmd = 10;              // 멤버 접근 연산자 .* / ->*

- 정적 멤버 함수: 정적 멤버는 자유 함수와 동일한 호출 규약이므로 “자유 함수 포인터” 타입에 담는다.

람다와 std::function 관계
- 캡처 없는 람다 → 함수 포인터 변환 가능
auto lam = [](int a, int b) { return a + b; };
int (*pf)(int,int) = lam; // OK, 동일 시그니처로 변환
- 캡처 있는 람다 → 변환 불가: 상태를 보유하므로 함수 포인터로 암시 변환되지 않는다. 필요하면 std::function을 사용한다.
- std::function과 비교
- 함수 포인터: 가볍고 빠르며 시그니처가 고정. 콜백의 오버헤드가 최소.
- std::function: 캡처 람다, 함수 객체, 바인딩 등 다양한 호출 대상을 타입 소거로 담을 수 있으나 간접 호출 비용과 할당 가능성이 있다.
