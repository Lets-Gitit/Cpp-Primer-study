# C++ 6장 정리: 함수(Functions)



## 1. 함수 기본(Function Basics)

- 핵심:
  - 함수 = 이름이 붙은 코드 블록, 호출하면 실행됨.
  - 구성: 반환 타입 + 이름 + 매개변수 목록 + 본문.
  - 호출 시 인자(arguments)로 매개변수(parameters)를 초기화.

- 예시(팩토리얼):
```cpp
int fact(int n) {
    int ret = 1;
    while (n > 1) ret *= n--;
    return ret;
}

int main() {
    std::cout << fact(5) << "\n"; // 120
}
```

- 추가 설명:
  - 인자 개수/타입이 정확히 맞아야 함.
  - 매개변수 순서대로 인자 초기화. 인자 평가 순서는 미정(컴파일러 자유)이므로 의존 금지.

***

## 2. 지역 객체와 수명(Local Objects)

- 핵심:
  - 지역 변수: 블록(함수 본문) 안에서만 유효, 블록을 벗어나면 소멸.
  - 지역 static: 최초 1회만 초기화, 프로그램 종료 시까지 유지.

- 예시(호출 횟수 카운트):
```cpp
std::size_t count_calls() {
    static std::size_t ctr = 0; // 호출 간 유지
    return ++ctr;
}

int main() {
    for (int i = 0; i < 3; ++i)
        std::cout << count_calls() << " "; // 1 2 3
}
```

- 실전 팁:
  - 지역 static은 상태 유지가 필요할 때만 신중히 사용(테스트/스레드 유의).

***

## 3. 선언과 분할 컴파일(Declarations & Separate Compilation)

- 핵심:
  - 함수 선언(프로토타입)은 헤더(.h)에, 정의는 소스(.cpp)에.
  - 여러 소스 파일로 분리하고 링크하여 실행 파일 생성.

- 예시(헤더와 소스):
```cpp
// Chapter6.h
int fact(int);

// fact.cc
#include "Chapter6.h"
int fact(int n) { /* ... */ }

// main.cc
#include "Chapter6.h"
int main() { std::cout << fact(5); }
```

- 이유:
  - 선언 일관성 유지, 재컴파일 최소화, 인터페이스/구현 분리.

***

## 4. 인자 전달 방식(Argument Passing)

### 4-1. 값 전달(pass by value)
- 설명: 인자를 복사하여 매개변수로 전달 → 함수 내 변경이 원본에 영향 없음.
```cpp
void reset(int i) { i = 0; }
int x = 42; reset(x); // x는 그대로 42
```

### 4-2. 참조 전달(pass by reference)
- 설명: 매개변수가 원본의 별칭 → 함수 내 변경이 원본 변경.
```cpp
void reset(int& i) { i = 0; }
int x = 42; reset(x); // x가 0으로 변경
```

### 4-3. const 참조(reference to const)
- 설명: 큰 객체 복사 방지 + 수정 금지.
```cpp
bool isShorter(const std::string& a, const std::string& b) {
    return a.size() < b.size();
}
```

### 4-4. 포인터 매개변수
- 설명: 포인터 자체는 값 전달이므로 “포인터가 가리키는 대상”에 접근/수정 가능.
```cpp
void setZero(int* p) { if (p) *p = 0; }
int x = 7; setZero(&x); // x = 0
```

- 안전 원칙:
  - 수정이 필요 없으면 “const 참조” 또는 “pointer to const” 사용.
  - literal/임시/const 객체는 “비-const 참조”에 바인딩 불가.

***

## 5. 배열 매개변수(Array Parameters)

- 핵심:
  - 배열은 함수 인자로 “포인터로 decay”됨 → 크기 정보 사라짐.
  - 크기 전달 방식 3가지: (1) 종료 마커, (2) begin/end 두 포인터, (3) 별도 size 인자.

- 예시(범위 지정 포인터 2개):
```cpp
void print(const int* beg, const int* end) {
    for (; beg != end; ++beg) std::cout << *beg << " ";
}

int a[3] = {1,2,3};
print(std::begin(a), std::end(a));
```

- 예시(참조로 정확한 크기 받기):
```cpp
void print10(int (&arr)[10]) {
    for (int x : arr) std::cout << x << " ";
}
```
- 주의: 타입에 크기가 포함되므로 정확히 10개짜리 배열만 받음.

***

## 6. 반환(return)과 반환 타입(Return Types)

- 핵심:
  - void가 아니면 모든 경로에서 “적절한 타입” 값 반환 필요.
  - 지역 객체에 대한 참조/포인터 반환 금지(소멸 후 댕글링).

- 예시(잘못된 반환):
```cpp
const std::string& bad() {
    std::string s = "temp";
    return s; // 댕글링 참조
}
```

- 예시(참조 반환 활용: lvalue 반환):
```cpp
char& get(std::string& s, std::string::size_type i) {
    return s[i];
}
std::string s = "hi";
get(s, 0) = 'H'; // s -> "Hi"
```

- 예시(재귀):
```cpp
int factorial(int n) {
    if (n > 1) return n * factorial(n - 1);
    return 1;
}
```

***

## 7. 오버로딩(Overloaded Functions)과 매칭(Matching)

- 핵심:
  - 같은 이름, 다른 매개변수(개수/타입) → 오버로딩.
  - 반환 타입만 다르면 에러.
  - 호출 시 “후보군 → 적합군 → 최적 일치(best match)” 순서로 결정.

- 예시:
```cpp
void print(int);
void print(double);
void print(const char*);

print(3);        // int 버전
print(3.14);     // double 버전
print("hello");  // const char* 버전
```

- 모호 호출 방지:
  - 불필요한 형변환 필요하지 않도록 시그니처 설계.
  - const/non-const 레퍼런스/포인터는 구분되는 오버로드가 가능.

***

## 8. 기본 인자(Default Arguments)

- 핵심:
  - 매개변수에 기본값 지정 → 호출 시 생략 가능(오른쪽부터 연속해서만 생략).
  - 선언은 헤더에 1회만(중복 지정 금지).

- 예시:
```cpp
void banner(int width = 80, char fill = '-') {
    for (int i = 0; i < width; ++i) std::cout << fill;
    std::cout << "\n";
}

banner();         // 80, '-'
banner(10);       // 10, '-'
banner(10, '#');  // 10, '#'
```

***

## 9. inline/constexpr 함수

- inline:
  - 함수가 호출되는 모든 장소에 삽입할 것을 요청.
  - 컴파일러가 반드시 수용하는 것은 아님.

```cpp
inline int square(int x) { return x * x; }
```

- constexpr:
  - 컴파일 타임 상수 표현 가능 함수. 인자/반환이 리터럴 타입이어야 하며 본문은 상수 표현 가능해야 함.
```cpp
constexpr int twice(int x) { return 2 * x; }
int a[twice(3)]; // 크기 6, 컴파일 타임 결정
```

***

## 10. 디버깅 보조(assert, NDEBUG)

- 핵심:
  - assert(조건): 거짓이면 메시지 출력 후 종료.
  - NDEBUG 정의 시 assert 비활성화.

```cpp
#include <cassert>
void f(int n) {
    assert(n > 0); // 개발 중 검증
}
```

- 팁:
  - assert는 “절대 발생하지 않아야 하는 조건” 검증에만 사용.
  - 런타임 오류 처리(입력 검증 등)와 혼동하지 않기.

***

## 11. 함수 포인터(Pointers to Functions)

- 핵심:
  - 함수 시그니처에 맞는 포인터 타입으로 저장/호출 가능.
  - 콜백, 전략 패턴 등에 유용.

- 예시:
```cpp
int add(int a, int b) { return a + b; }

int (*op)(int, int) = add;
std::cout << op(2, 3) << "\n"; // 5
```

- 오버로드 함수의 포인터:
  - “포인터 타입”으로 어느 오버로드를 가리킬지 결정됨.
```cpp
void f(int);
void f(unsigned);

void (*pf)(unsigned) = f; // f(unsigned)를 선택
```
