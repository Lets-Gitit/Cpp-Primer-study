# Chapter6

---

## [ 분할 컴파일 ]

- 소스 코드를 여러 개의 파일로 나누어 개발하고 관리하는 기법입니다.
- 프로젝트의 규모가 커질수록 코드의 가독성, 재사용성, 관리 효율성을 높이고 전체 빌드 시간을 단축하는 데 매우 중요한 역할을 합니다.

### 분할 컴파일의 동작 원리

1. 컴파일 단계
    - 컴파일러는 각각의 소스 파일을 개별적으로 컴파일합니다.
    - 이 과정에서 해당 소스 파일이 포함하는 헤더 파일의 선언들을 참조하여 문법 오류 등을 확인합니다.
    - 컴파일이 성공하면, 각 소스 파일은 기계어 코드인 오브젝트 파일로 변환됩니다.
    - 이 단계에서는 다른 소스 파일의 내용은 전혀 알지 못합니다. 그저 헤더 파일의 선언을 믿고 컴파일을 진행할 뿐입니다.
2. 링크 단계
    - 링커는 컴파일러가 생성한 모든 오브젝트 파일들을 하나로 합칩니다.
    - 이 과정에서 한 오브젝트 파일이 호출하는 함수나 사용하는 변수가 다른 오브젝트 파일에 있는지 찾아서 연결합니다.
    - 만약 함수의 선언만 있고 실제 정의를 찾지 못하면 undefined reference 와 같은 링크 오류가 발생합니다.
    - 모든 연결이 성공적으로 끝나면 최종적으로 하나의 실행 파일이 만들어집니다.

---

## [ Pass - by - reference  VS  Pass - by - pointer ]

### 개념 차이

- 참조 ( & )
    - 한 번 바인딩되면 다른 걸 가리킬 수 없고, 자체적으로 null 상태가 없습니다.
- pointer
    - 언제든 다른 주소를 담을 수 있고, nullptr 가 될 수 있습니다.

### 호출 / 사용법

```cpp
void f_ref(int& x);   // 참조로 받음
void f_ptr(int* p);   // 포인터로 받음

int a = 10;
f_ref(a);    // 그냥 변수로 호출
f_ptr(&a);   // 주소를 넘겨야 함
```

### 원본 수정 가능 여부

- 둘다 원본을 바꿀 수 있습니다.
- 차이
    - T&는 반드시 실제 객체가 온다는 전제가 있어 null 체크가 불필요 합니다
    - T* 는 nullptr 가능합니다. 따라서 널 체크가 필요합니다.

### 재지정 가능성

- 참조
    - 한번 지정하면 / 바인딩되면 다른 걸 가리킬 수 없습니다.
- pointer
    - 언제든지 다른 곳을 가리키게 변경할 수 있습니다.

---

## [ 함수 오버로딩 모호한 호출 ]

### 모호한 호출이란?

- 컴파일러가 함수 호출 시 어떤 오버로드된 함수를 선택해야 할지 명확히 판단하지 못하는 상황을 말합니다.
- 주로 함수 오버로딩을 사용할 때 매개변수의 타입이나 개수가 호출 시점에 제공된 인자와 정확히 매칭되지 않을 때 발생합니다.

```cpp
#include <iostream>
void print(int x) {
    std::cout << "정수: " << x << std::endl;
}

void print(double x) {
    std::cout << "실수: " << x << std::endl;
}

int main() {
    print(10.0f); // float 타입 인자
    return 0;
}
```

- 10 은 float 타입이지만 printf 함수는 int와 double용 오버로드만 정의되어 있으므로, 컴파일러는 float를 int로 변환할지 double로 변환할지 결정하지 못해 호출 오류를 발생시킵니다.

### 발생하는 주요 원인

1. 타입 변환의 모호성
2. 매개변수 개수나 타입이 비슷한 경우
3. 기본 인자와의 충돌

---

## [ argv, argc ]

### argc

- 프로그램에 전달된 인자의 총 개수를 지정하는 정수 변수입니다.
- 실행되는 프로그램의 이름 자체도 인자로 취급되기 때문에 argc의 최소값은 항상 1입니다.

## argv

- 프로그램에 전달된 인자들의 실제 내용을 담고 있는 배열입니다.
- c 스타일 문자열 포인터입니다.
    - argv : argument vector의 약자입니다.
    - argv[0] : 실행된 프로그램의 이름
    - argv[1] : 프로그램에 전달된 첫 번째 인자
    - argv[2] : 프로그램에 전달된 두 번째 인자
    - argv[argc] : 이 위치에는 항상 NULL 포인터가 들어가 있습니다.

---

## [ assert ]

- 조건이 거짓일 경우 프로그램이 즉시 종료됩니다.
- NDEBUG 매크로를 정의하면 assert가 무시됩니다.

### 동작 방식

- assert는 인수 ( 스칼라 타입이 있어야 합니다.  ) 가 있는지 확인합니다.
- 인수가 0과 같지 않은 경우 추가 효과가 없습니다.
- 그렇지 않다면 assert는 표준 오류 스트림에 대한 진단을 생성하고 std::abort()를 호출합니다.

**Cpp 20까지의 assert**

- assert는 조건이 거짓일 경우, 해당 조건을 문자열로 출력하고 프로그램을 종료합니다.
- 이때 출력되는 메시지는 조건식 자체만 포함됩니다.
    - Assertion failed : x == 10
- 하지만 && “문자열” 을 사용하면 문자열이 같이 출력됩니다.

**Cpp 26 이후의 assert**

- assert가 가변 인자 매크로를 활용하여, 조건 외에도 사용자 정의 메시지를 받을 수 있게 됐습니다.
- assert( condition, message …. ) 처럼 가변인자를 받아서 다양한 타입의 메시지를 출력할 수 있습니다.
    
    ```cpp
    int x = 5;
    assert(x = 10, "Expected 10 but got" , x);
    ```