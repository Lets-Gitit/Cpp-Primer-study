3.1 namespace , using 선언

namespace는 클래스, 인터페이스, 구조체, 열거형 등을 그룹화하는 데 사용되는 이름 공간



using 선언은 namespace 에서 이름으 구분하지 않고 사용할 수 있세 해줌

헤더 코드 내 using 선언 x => 헤더를 포함하는 모든 프로그램 동일한 using 선언

=> 해당 라이브러리 이름을 사용 않는 프로그램에서 이름 충돌할 수 있음



핵심 동작 => 이름을 현재 범위(scope) 에 도입한다 



using은 기존에 선언된 이름(타입, 함수, 변수 등)을 현재 범위로 가져와서 직접 사용할 수 있게 해주는 명령

and

 using 선언은 정의가 아닌 선언 즉, 새로운 엔티티를 만드는 것이 아니라 기존 엔티티에 대한 별칭 또는 접근 경로를 제공



1. using namespace std;

- std 네임스페이스에 정의된 모든 이름을 현재 범위로 도입

- std::cout → cout으로 사용 가능



2. using std::cout;

- std 네임스페이스의 cout만 현재 범위로 도입

- 충돌 위험이 적고 안전



3. using MyInt = int;

- MyInt를 int의 별칭으로 도입

- 템플릿 타입에도 사용 가능



내부적 처리

- 컴파일러는 using을 만나면 해당 이름을 현재 범위의 심볼 테이블에 등록합니다.

- 이후 코드에서 해당 이름을 사용할 때, 원래 정의된 위치로 연결합니다.

- using은 오버로드된 함수 집합도 도입할 수 있으며, 이로 인해 모호성 오류가 발생할 수도 있습니다.



결국 using 의 기능은 이름(심볼) 을 현재의 심볼테이블에 포함하는 기능

(현재 파일의 심볼테이블에서 using 사용시 심볼테이블 검색이 확장 되는 개념)


1. using namespace std;

std 이름 공간의 이름들을 심볼 검색대상에 포함하는것 



2. using std::cout;

std::out 이름을 심볼 검색대상에 포함하는것 



3. using MyInt = int;

MyInt라는 이름 심볼 테이블에 등록 

{

등록 과정에서 int 를 참조하는 타입 별칭으로 저장

이후 코드에서 MyInt 등장시 int로 치환

}



즉

- using이 타입 별칭으로 쓰일 때는 → 새로운 심볼을 등록

- using이 네임스페이스 심볼 도입으로 쓰일 때는 → 기존 심볼을 현재 스코프에 확장





3.2 lib string type 

std 라이브러리에서 지원하는 문자열 클래스

초기화

string s1;

string s2(s1);

string s3 = s2; //  s2(s1); 와 동등한 기능

string s4("value");

string s5 = "value";//s4("value") 와 동등한 기능

string s6(n , 'a'); // n 사이즈 만큼 'a'로 초기화



연산

- os << s

→ 문자열 s를 출력 스트림 os에 씀. 반환값은 os.

- is >> s

→ 입력 스트림 is에서 공백으로 구분된 문자열을 s에 읽어들임. 반환값은 is.

- getline(is, s)

→ 입력 스트림 is에서 한 줄을 읽어 s에 저장. 반환값은 is.

- s.empty()

→ 문자열 s가 비어 있으면 true, 아니면 false 반환.

- s.size()

→ 문자열 s의 문자 개수를 반환.

- s[n]

→ 문자열 s의 n번째 위치(0부터 시작)의 문자를 참조로 반환.

- s1 + s2

→ 문자열 s1과 s2를 이어붙인 새로운 문자열 반환.

단 "abc" + "def" 같은 문자열 리터럴 간 연산은 x

- s1 = s2

→ 문자열 s1의 내용을 s2로 대체.

- s1 == s2

→ 두 문자열이 같은 문자들로 구성되어 있으면 true. 대소문자 구분함.

- s1 != s2

→ 두 문자열이 다르면 true.

- <, <=, >, >=

→ 문자열 비교는 대소문자 구분하며, 사전(dictionary) 순서를 따름.



문자 검사

 isalnum(c)  c가 문자 또는 숫자이면 true  

 isalpha(c)  c가 문자이면 true  

 iscntrl(c)  c가 제어 문자이면 true  

 isdigit(c)  c가 숫자이면 true  

 isgraph(c)  c가 공백이 아니면서 출력 가능한 문자이면 true  

 islower(c)  c가 소문자이면 true  

 isprint(c)  c가 출력 가능한 문자이면 true (공백 포함)  

 ispunct(c)  c가 구두점 문자이면 true (제어 문자, 숫자, 문자, 공백 제외)  

 isspace(c)  c가 공백 문자이면 true (스페이스, 탭, 개행 등)  

 isupper(c)  c가 대문자이면 true  

 isxdigit(c)  c가 16진수 숫자이면 true (0-9, A-F, a-f)  



문자 변환

 tolower(c)  c가 대문자면 소문자로 변환, 아니면 그대로 반환  

 toupper(c)  c가 소문자면 대문자로 변환, 아니면 그대로 반환  



범위 기반 for 

for(선언문 : 표현식) 선언문

for (선언문 : 표현식) {

    // 반복할 코드

}

- 표현식: 배열, 컨테이너(vector, list 등), 이터러블 객체

- 선언문: 각 요소를 받을 변수 선언


string s("hello");

for (char &c: s) {

 	c = toupper(c);    

}

cout << s << endl;//HELLO 출력



3.3 lib vector type

vector 란 모든 객체가 동일 타입을 가진 객체 집합 => 인덱싱 가능 

클래스 템플릿(?) , 템플릿->함수 나 클래스 X ,But 컴파일러가 함수 나 클래스 생성하기위한 지시 가능
컴파일러가 템플릿-> 클래스 or 함수 , 인스턴스화 (해당과정에서 인스턴스화할 클래스나 함수 종류 지정)

템플릿이름<종류>

vector<int> iVec;

vector<Object> objectVec;

vector<vector<string>> file;// 벡터의 요소는 문자열 벡터

- 각 요소는 vector<string> 타입 → 즉, 문자열들의 벡터

- file은 문자열 벡터들의 벡터.

레거시 컴파일러 vector<vector<string> >; // 공백 요구 old style



초기화 

 // T 타입 객체 저장하는 벡터 , 빈벡터로 초기화

vector<T> v1;

//V2 는 V1의 복사본

vector<T> v2(v1);

vector<T> v2 = v1;



//val값을 가진 n개의 요소로 초기화

vector<T> v3(n, val);



//값이 초기화된 객체 n개 생성함

vector<T> v4(n);



//{a, b, c...}에 있는 값들로 초기화됨

vector<T> v5{a, b, c...};

vector<T> v5 = {a, b, c...};


연산 
- v.empty()
→ v가 비어 있으면 true, 아니면 false 반환

- v.size()
→ v의 요소 개수를 반환

- v.push_back(t)
→ 값 t를 v의 끝에 추가

- v[n]
→ v의 n번째 요소에 대한 참조 반환

- v1 = v2
→ v1의 요소를 v2의 복사본으로 대체

- v1 = {a, b, c ...}
→ v1의 요소를 {a, b, c ...} 리스트로 대체

- v1 == v2
→ 두 벡터가 요소 수가 같고, 각 요소가 동일하면 true

- v1 != v2
→ 두 벡터가 다르면 true

- <, <=, >, >=
→ 사전(dictionary) 순서를 기준으로 비교

- push_back
다음의 연산을 통해 벡터를 생성할때 
빈벡터를 생성한뒤 실행과정에서 요소를 추가할 수 있음

고정 크기 벡터 vs push_back 방식

push_back 를 사용하는 경우 
- 동적 크기 조절
- vector는 내부적으로 capacity를 관리하며, 공간이 부족할 때 자동으로 더 큰 메모리를 할당하고 기존 데이터를 복사함.
- 이 과정은 암묵적으로 최적화되어 있어, 대부분의 경우 성능 저하가 크지 않음.
- 암묵적 메모리 최적화
- vector는 메모리를 2배씩 증가시키는 방식으로 재할당하므로, 전체적으로 보면 O(n)이 아닌 평균적으로 O(1) 시간 복잡도로 push_back이 작동함.
- 가독성과 유지보수
- push_back은 코드 흐름이 명확하고, 조건에 따라 요소를 추가할 수 있어 유연한 로직 구현에 적합함.
- 초기 크기를 알 수 없는 경우
- 입력 데이터가 동적일 때는 고정 크기보다 push_back이 훨씬 적합함. 예: 사용자 입력, 파일 읽기, 조건 기반 필터링 등.

고정 크기를 사용하는경우
- 성능이 극도로 중요한 경우 (예: 실시간 시스템, 게임 엔진 등)
- 데이터 크기가 명확히 정해져 있고, 재할당을 피하고 싶을 때
- 이럴 땐 reserve()를 사용해 push_back 방식의 단점을 보완
std::vector<int> v;
v.reserve(1000); // 미리 1000개의 공간 확보

고정 사이즈 방식 vs push_back 방식  은
어떻게 보면 일반 적인 배열 과 벡터 비교와 유사(? 결국 유연함을 위해 메모리 재할당을 하는가 안하는가 에서 발생하는 비용을 고려하는 관점이라면, 물론 벡터의 경우 풍부한 메서드 (size(), empty(), insert(), 경계 검사 (at() 사용 시)등과 같은 다양한 기능과 유연성을 제공해줌
)
결국 배열을 사용하냐 벡터를 사용하냐의 경우도 
- 배열: 고정된 크기의 데이터 처리, 임베디드 시스템, 성능 최우선 상황
- 벡터: 입력 크기가 가변적일 때, 코드 유지보수가 중요할 때, STL과 함께 사용할 때
위와 같은 코드의 목적과 상황을 적절히(?) 고려하면서 설계필요
 (아니면 reserve() 로 고정크기 벡터로 재할당 비용을 줄여 배열처럼 빠르게 작동하면서 벡터의 유연성을 가지는(? 고정된 배열에 벡터의 기능이 필요한 이유가? 필요없는 기능이 덕지붙은 배열을 만들어버리는 거일 수 도....))


3.4 Iterators(반복자) 소개 
*Iterator(반복자)**는 컨테이너의 요소들을 일관된 방식으로 순회하고 접근할 수 있게 해주는 객체
ex
- *it → 현재 요소 접근
- ++it → 다음 요소로 이동
- it != container.end() → 끝까지 순회 여부 확인

std::vector<int> v = {1, 2, 3, 4};
for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << " ";
}

포인터와 달리 주소 연산자를 사용 X
대신 반복자를 가진 타입들은 반복자를 반환하는 멤버가짐
특히 begin(첫번째 요소) 과 end(마지막 요소, 끝보다 한칸 앞 에 위치한 반복자 ,반복자의 끝은 모든 요소를 처리한 경우에 대한 마커로 사용) 라는 멤버 가짐
=> 컨테이너의 요소에 대한 안전한 접근이 가능

반복자 컨테이너의 연산자

- *iter
→ 반복자가 가리키는 요소에 대한 참조 반환
- iter->mem
→ 반복자가 가리키는 객체의 멤버 mem에 접근
→ (*iter).mem과 동일
- ++iter
→ 반복자를 다음 요소로 이동
- --iter
→ 반복자를 이전 요소로 이동 (Bidirectional 이상에서만 가능)
- iter1 == iter2
→ 두 반복자가 같은 요소를 가리키면 true
- iter1 != iter2
→ 두 반복자가 다른 요소를 가리키면 true

반복자 연산 사용예시(여기서 it 이 string s의 반복자)
string s("some string");
 if (s.begin() != s.end()) { // make sure s is not empty
 auto it = s.begin();    // it denotes the first character in s
 *it = toupper(*it);     // make that character uppercase
 }
//Some string 로 바뀜

for (auto it = s.begin(); it != s.end() && !isspace(*it);++it)
 *it = toupper(*it); // capitalize the current character
반복자의 경우 < 아닌 != 을 사용함으로서 처리 중인 컨테이너의 정확한 타입에 대해 걱정할 필요X

반복자 유형
일반 반복자(읽기 쓰기 가능)
vector<int>::iteratorit;//it 는vector<int> 요소를 읽고 쓸 수 있음
string::iteratorit2; //it2 는 문자열의 문자를 읽고 쓸 수 있음

상수 반복자(읽기 만 가능 )
vector<int>::const_iteratorit3;//it3 는 요소를 읽지만 쓸 수 없음
string::const_iterator it4;//it4 는 문자를 읽지만 쓸 수 없음

반복자 산술 연산(- vector와 string은 랜덤 액세스 반복자를 제공하므로 이런 연산들이 가능함)
iter + n, iter - n  : 반복자를 n만큼 앞/뒤로 이동시킴
iter1 += n, iter1 -= n : 반복자에 n을 더하거나 빼서 자기 자신에 대입
iter1 - iter2 : 두 반복자 사이의 거리(요소 개수)를 반환
> , >= , < , <= : 반복자 간의 위치 비교 (앞에 있는지, 뒤에 있는지 등)
3.5 arrays
vector 와 유사 데이터 구조 but 
vector 의 경우 단일 타임의 객체를 담고 있는 컨테이너 , 위치를 통해 접근 
arrays 의 경우 크기가 고정되어 있고 요소 추가 x => 이를 통해 런타임 성능이 좋으나 유연성 을 잃음(자세한 내용은 벡터부분 정리 마지막 부분)

배열 초기화
unsigned cnt = 42;          // not a constant expression
 constexpr unsigned sz = 42; // constant expression
                            // constexpr see § 2.4.4 (p. 66)
 int arr[10];             // array of ten ints
 int *parr[sz];           // array of 42 pointers to int
 string bad[cnt];         // error: cnt is not a constant expression
 string strs[get_size()]; // ok if get_size is constexpr, error otherwise

배열 초기화 시 그 사이즈가 컴파일 시간에 알려져야함 
=>상수 표현식이어야 함
=>타입이 명시되어야 하며 auto 사용 X

명시적 초기화 
 const unsigned sz = 3;
 int ia1[sz] = {0,1,2};        // array of three ints with values 0, 1, 2
 int a2[] = {0, 1, 2};         // an array of dimension 3
 int a3[5] = {0, 1, 2};        // equivalent to a3[] = {0, 1, 2, 0, 0}
 string a4[3] = {"hi", "bye"}; // same as a4[] =  {"hi", "bye", ""}
 int a5[2] = {0,1,2};          // error: too many initializers

복사 , 할당 금지
int a[] = {0, 1, 2}; // array of three ints
int a2[] = a; // error: cannot initialize one array with another       
a2 = a;  // error: cannot assign one array to another          

복잡한 배열 선언 
 int *ptrs[10]; //  ptrs is an array of ten pointers to int
 int &refs[10] = /* ? */;  //  error: no arrays of references
 =>
	C++에서는 참조(reference)의 배열은 허용X.
	참조는 초기화가 반드시 필요하고, 재배치 불가능한 특성 때문에 배열이 안됨.
	=>참조는 변수의 별칭이기 때문에, 배열처럼 복수의 참조를 하나의 이름으로 관리하는 구조가 성립하지 않음

 int (*Parray)[10] = &arr; //  Parray points to an array of ten ints
 =>
	Parray는 10개의 int를 담는 배열을 가리키는 포인터.
	=>즉 Parray는 int size * 10 짜리 메모리 구조를 가리키는 포인터
	arr은 int arr[10];처럼 선언된 배열이어야 합니다.
	(*Parray)[0] = 42; // arr[0] = 42

 int (&arrRef)[10] = arr;  //  arrRef refers to an array of ten ints
 =>
	arrRef는 10개의 int를 담는 배열에 대한 참조.
	arr은 int arr[10];처럼 선언되어야함.
	즉 arrRef 는 arr 의 별칭이됨
- 배열의 요소접근
배열의 요소 접근시 접근 하는 인덱스가 범위내에 있는지 주의 해야하며 배열의 경계를 넘어서는 것을 막아주어야한다. 포인터 배열의 경우 인덱스 범위 뿐이아닌 각 요소가 유효한지 등 여러 요소를 살펴주어야한다.

- 포인터를 통한 배열의 접근 
배열의 주소는 첫번째 요소의 주소 
	= 배열은 base 주소 + offset × stride로 구성된 연속 메모리 구조이다.
즉 포인터를 통해 배열에 접근한다는것은 
배열에 어떤 base(주소) 부터 어떤 stride만큼 offset을 읽을 지를 정하여 요소를 탐색하는것
이경우 배열의 stride 를 확실히 아는것이 중요!(배열의 요소 타입 이지만 구조체 배열의 경우 구조중 특정 요소에만 접근하고 싶은 경우 주의 필요 )

즉 포인터로 배열 접근시 해당 포인터 타입에 맞게 +연산시 stride 가 들어감 
포인터 타입을 정확히 명시해주어야함 

예시 
struct Vertex{
	float pos[4];
	float color[4];
}

float* Buffer = (float*)malloc(sizeof(Vertex) * n );

int stride = 8;
for(int i = 0; i < n; i++)
{

    *(Buffer + i * stride + 0) = x;
    *(Buffer + i * stride + 1) = y;
    *(Buffer + i * stride + 2) = z;
    *(Buffer + i * stride + 3) = w;

    *(Buffer + i * stride + 4) = r;
    *(Buffer + i * stride + 5) = g;
    *(Buffer + i * stride + 6) = b;
    *(Buffer + i * stride + 7) = a;

}

cpp 에서는 cStyle의 문자열 보다 cpp 에서 제공해주는 string 을 사용
 cStyle의 문자열을 지원을하나 위험

벡터의 경우 배열의 형태로 초기화 가능 
int int_arr[] = {0, 1, 2, 3, 4, 5};
 // ivec has six elements; each is a copy of the corresponding element in int_arr
 vector<int> ivec(begin(int_arr), end(int_arr));

ex)
// copies three elements: int_arr[1], int_arr[2], int_arr[3]
 vector<int> subVec(int_arr + 1, int_arr + 4);


3.6 다차원 arrays

C++에는다차원 배열이 없음 .일반적으로 다차원 배열로 불리는 것은 실제로는 배열구조의 배열
즉 
int ia[3][4]; 의경우 
int 크기 * 4 짜리 요소를 가진 3크기 배열
결국 
int 크기 * 4 짜리 요소를 가진 3크기 배열을 
int* 단위로 접근함으로서 다차원 배열로 사용하는것 
즉 
(int*)ia 로 인식하게 된다면 모든 요소를 int 단위로 인식하면서 int[12] 로 인식
(int[4]*)ia 로 인식한다면 각 행을 int[4] 배열로 인식하여 int[3][4] 로 인식

- 메모리에는 int 12개가 연속적으로 배치됨
- 하지만 타입을 int[4]로 지정하면, 16바이트 단위로 끊어서 접근하게 됨
즉:
int (*p)[4] = ia;

- p[0] → ia[0] → int[4] (첫 16바이트)
- p[1] → ia[1] → 다음 16바이트
- p[2] → ia[2] → 마지막 16바이트

그렇기에 이차원 배열을 포인터로 전달시 해석의 방식도 전달해야함

대표적으로 매개변수로 이차원 배열 전달시 기본 타입의 1차원 배열 처럼 전달 stride 를 전달 
or (int[행 사이즈]*)로 전달 해야함

지정 타입을 결국 행사이즈 만큼의 구조만든 것을 하나의 요소로 하여 배열은 만든것을 
행사이즈 만큼을 stride로 한뒤 지정타입으로 데이터를 접근한것





