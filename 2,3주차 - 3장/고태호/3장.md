# **C++ 3장 정리**

## **1. 네임스페이스 using 선언**

- **핵심:**
    
    **`using std::cout;`** 처럼 선언하면 **`std::`** 없이 바로 cout, cin 등을 쓸 수 있음.
    
- **자세한 설명:**
    
    매번 **`std::cout`**, **`std::cin`**을 쓰는 것이 번거로우니, 한 번만 **`using std::cout;`** 선언하면 그 이후로는 **`cout`**만 써도 됩니다. 각 이름마다 별도로 선언해야 하고(**`using std::cin; using std::cout;`**), 헤더 파일에서는 사용하지 않는 것이 좋습니다. 헤더 파일에 using을 쓰면 그 헤더를 포함하는 모든 프로그램이 영향을 받아서 이름 충돌이 생길 수 있기 때문입니다.
    

## **2. string 타입 (문자열)**

- **초기화 방법:**
    
    ```cpp
    cppstring s1;              *// 빈 문자열*
    string s2 = "hello";    *// 복사 초기화*
    string s3("hello");     *// 직접 초기화*
    string s4(10, 'c');     *// 직접 초기화 ('c'를 10개)*
    ```
    
- **주요 연산과 자세한 설명**
    - **`s.empty()`**: 문자열이 비어있는지 확인. 비어있으면 true, 아니면 false 반환
    - **`s.size()`**: 문자열의 길이(문자 개수) 반환. 반환 타입은 **`string::size_type`**이라는 unsigned 타입
    - **`s1 + s2`**: 두 문자열을 연결한 새로운 문자열 생성
    - **`s1 += s2`**: s1 뒤에 s2를 추가 (s1이 변경됨)
    - **`getline(cin, s)`**: 공백을 포함한 한 줄 전체를 입력받음 (cin >> s는 공백에서 끊어짐)
    - **`s[n]`**: n번째 문자에 접근 (0부터 시작), 범위를 벗어나면 정의되지 않은 동작
- **문자 처리 방법과 자세한 설명:**
    
    ```cpp
    cpp*// 모든 문자를 처리할 때 - 범위 기반 for문 (권장)*
    for (auto &c : str) 
        c = toupper(c);  *// 참조(&)를 써야 실제 문자가 변경됨// 특정 문자만 처리할 때 - 첫 단어만 대문자로*
    for (decltype(s.size()) i = 0; i != s.size() && !isspace(s[i]); ++i)
        s[i] = toupper(s[i]);
    ```
    

## **3. vector 타입 (동적 배열)**

- **초기화 방법과 자세한 설명:**
    
    ```cpp
    cppvector<int> v1;              *// 빈 벡터 (가장 일반적)*
    vector<int> v2(10);          *// 10개 원소, 모두 0으로 초기화*
    vector<int> v3(10, -1);      *// 10개 원소, 모두 -1로 초기화*
    vector<int> v4{1,2,3};       *// 리스트 초기화 (중괄호 사용)*
    vector<int> v5 = {1,2,3};    *// 위와 동일*
    ```
    
- **주요 연산과 자세한 설명**
    - **`v.push_back(value)`**: 벡터 끝에 원소 추가. 벡터가 자동으로 크기 확장
    - **`v.size()`**: 현재 벡터의 원소 개수 반환
    - **`v.empty()`**: 벡터가 비어있는지 확인
    - **`v[i]`**: i번째 원소에 접근 (존재하는 원소만 접근 가능!)
    - **중요:** 첨자(**`[]`**)는 원소를 추가하지 않음! 새 원소 추가는 반드시 **`push_back`** 사용
- **벡터의 동적 성장 원리:**
    
    벡터는 내부적으로 배열을 사용하지만, 용량이 부족하면 더 큰 메모리를 할당하고 기존 원소들을 복사합니다. 이 과정이 최적화되어 있어서 빈 벡터에서 시작해서 push_back으로 추가하는 것이 효율적입니다.
    

## **4. 반복자(Iterator)**

- **기본 사용법과 자세한 설명:**
    
    ```cpp
    cppvector<int> v = {1,2,3,4,5};
    auto it = v.begin();   *// 첫 번째 원소를 가리키는 반복자*
    auto end_it = v.end(); *// 마지막 원소의 다음을 가리키는 반복자// 반복자로 순회*
    for (auto it = v.begin(); it != v.end(); ++it) {
        cout << *it << " ";  *// *it로 값에 접근*
    }
    ```
    
- **반복자 타입과 자세한 설명:**
    - **`iterator`**: 읽기/쓰기 모두 가능
    - **`const_iterator`**: 읽기만 가능 (값 변경 불가)
    - **`v.cbegin()`**, **`v.cend()`**: 항상 const_iterator 반환
- **반복자를 사용하는 이유:**
    
    포인터와 비슷하지만 더 일반적입니다. 모든 컨테이너(vector, string, list 등)에서 동일한 방식으로 사용할 수 있어서 코드의 일관성을 유지할 수 있습니다. **`!=`** 연산자를 사용하는 이유도 모든 컨테이너에서 지원하기 때문입니다.
    

## **5. 배열 (Array)**

- **정의와 제한사항:**
    
    ```cpp
    cppint arr[10];          *// 10개 int 배열*
    int arr2[] = {1,2,3}; *// 크기 3으로 자동 추론*
    const int size = 5;
    int arr3[size];       *// 크기는 컴파일 타임에 상수여야 함*
    ```
    
- **중요한 제한사항과 자세한 설명:**
    - **크기 고정:** 컴파일 시간에 크기가 결정되며, 런타임에 변경 불가
    - **복사/할당 불가:** **`int a[] = b;`** 또는 **`a = b;`** 같은 연산 불가능
    - **크기 변경 불가:** push_back 같은 함수 없음
    - **자동 범위 검사 없음:** 잘못된 인덱스 사용 시 컴파일 에러 없이 실행되지만 예측 불가능한 결과
- **포인터와의 관계 및 자세한 설명:**
    
    ```cpp
    cppint arr[5] = {1,2,3,4,5};
    int *p = arr;        *// 배열명 → 첫 번째 원소 포인터로 자동 변환*
    int *end = arr + 5;  *// 끝을 지난 포인터// 표준 라이브러리 함수 사용 (권장)*
    int *beg = begin(arr);
    int *last = end(arr);
    ```
    
    배열 이름을 사용하면 대부분의 경우 첫 번째 원소의 포인터로 자동 변환됩니다. 이것이 배열과 포인터가 밀접한 관련이 있는 이유입니다.
    

## **6. C 스타일 문자열 (자세한 설명)**

- **핵심:** **절대 사용하지 말 것!** string 타입 사용 강력 권장
- **왜 사용하면 안 되는가 - 자세한 설명:**
    
    **1. 버퍼 오버플로우 위험성:**
    
    ```cpp
    cppchar str[5] = "hello";  *// 실제로는 6바이트 필요 (null 문자 포함)// 메모리 오버플로우 발생! 심각한 보안 문제의 원인*
    ```
    
    **2. 수동 메모리 관리의 어려움:**
    
    ```cpp
    cppchar dest[100];  *// 충분한 크기인지 항상 확인해야 함*
    strcpy(dest, src1);      *// 복사*
    strcat(dest, src2);      *// 연결// dest 크기를 잘못 계산하면 재앙적 결과*
    ```
    
    **3. 함수들이 안전하지 않음:**
    
    - **`strlen()`**: null 문자가 없으면 무한 루프
    - **`strcpy()`**, **`strcat()`**: 대상 버퍼 크기 검사 없음
    - 모든 책임이 프로그래머에게 있음
    
    **4. 실제 사용 예시 (절대 따라하지 말 것):**
    
    ```cpp
    cppchar ca1[] = "Hello";
    char ca2[] = "World";
    char result[100];  *// 크기 추정이 정확한가?*
    strcpy(result, ca1);    *// Hello 복사*
    strcat(result, " ");    *// 공백 추가*
    strcat(result, ca2);    *// World 추가// 만약 result 크기를 잘못 계산했다면?*
    ```
    
    **5. string과의 비교:**
    
    ```cpp
    cpp*// 안전한 string 사용*
    string s1 = "Hello";
    string s2 = "World";
    string result = s1 + " " + s2;  *// 간단하고 안전*
    ```
    

## **7. 핵심 원칙들 (자세한 설명)**

## **7-1. 안전성 원칙**

**범위 확인의 중요성:**

```cpp
cpp*// 잘못된 예*
vector<int> v(10);
v[15] = 42;  *// 컴파일은 되지만 실행 시 문제 발생// 올바른 예*
if (index < v.size()) {
    v[index] = value;  *// 안전한 접근*
}
```

**범위 기반 for문 사용의 장점:**

- 인덱스 오류 완전 방지
- 코드가 간결하고 읽기 쉬움
- 모든 컨테이너 타입에서 동일하게 작동

```cpp
cpp*// 권장: 범위 기반 for*
for (auto &element : container) {
    *// element 처리*
}

*// 비권장: 수동 인덱스 관리*
for (size_t i = 0; i < container.size(); ++i) {
    *// container[i] 처리 - 실수 가능성*
}
```

## **7-2. 성능과 효율성**

**벡터의 동적 확장 전략:**

- 벡터는 메모리가 부족할 때 일반적으로 현재 크기의 2배로 확장
- 이 때문에 push_back의 평균 시간복잡도는 O(1)
- 미리 큰 크기로 잡는 것보다 빈 벡터에서 시작하는 것이 더 효율적

**auto 사용의 이점:**

```cpp
cpp*// 복잡한 타입을 명시적으로 쓰는 것보다*
vector<int>::iterator it = v.begin();

*// auto를 사용하는 것이 간결하고 실수 방지*
auto it = v.begin();
```

## **7-3. 문법과 관례**

**!= 사용 권장 이유:**

```cpp
cpp*// vector와 string은 < 연산자 지원*
for (auto it = v.begin(); it != v.end(); ++it) *// 권장*
for (auto it = v.begin(); it < v.end(); ++it)  *// 가능하지만 비권장// 이유: 다른 컨테이너(list 등)는 < 연산자를 지원하지 않을 수 있음// !=는 모든 반복자에서 지원되므로 일관성 있는 코드 작성 가능*
```

**참조 사용 시기:**

```cpp
cpp*// 값을 변경하지 않을 때*
for (const auto &element : container)  *// 복사 비용 절약// 값을 변경할 때*
for (auto &element : container)  *// 실제 원소 변경 가능*
```

## **7-4. 보안과 안정성**

**버퍼 오버플로우가 위험한 이유:**

- 시스템 메모리를 예측 불가능하게 덮어씀
- 악성 코드 실행 가능성
- 프로그램 충돌 또는 데이터 손실
- 대부분의 보안 취약점의 근본 원인

**방어 방법:**

1. 배열 대신 vector 사용
2. C 문자열 대신 string 사용
3. 범위 기반 for문 적극 활용
4. 반복자 사용으로 포인터 산술 최소화
