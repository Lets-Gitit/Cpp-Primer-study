# 4장 정리

## 정수 승격과 산술 변환

“정수 타입 피연산자는 일반적으로 더 큰 정수 타입으로 승격한다.”

**정수 승격(integral promotion)**

`bool`, `char`(signed/unsigned), `short` 등은 연산에 참여할 때 보통 `int`(혹은 `unsigned int`)로 승격된다.

---

## 연산자 다중 정의(오버로딩)

“다중 정의한 연산자 → 피연산자 수, 연산자 우선순위와 결합법칙은 바꿀 수 없다.”

그러나 `&&`, `||`, `?:`등의 ‘제어 흐름’ 연산자는, **평가 순서를 보장**한다.

---

## 좌변값(lvalue)과 우변값(rvalue)

“좌변값과 우변값에 대하여”

- **좌변값(lvalue)**: “이름 붙은, 지속적으로 존재하는 것” — 대입의 **왼쪽**에 올 수 있고, 주소를 취할 수 있는 것.
  예) 변수 `x`, 전위증가 `++i`의 결과, `*p`의 결과, 문자열 리터럴 등
- **우변값(rvalue)**: 일시적인 값 — 리터럴(정수·실수), 표현식의 계산 결과 등.
  예) `i + j`, `std::string("tmp")`의 임시
- **C++11 이후 값 범주(참고)**: `lvalue`, `xvalue(만료된 값)`, `prvalue(순수 rvalue)`로 더 정교해졌다.
- **증감 연산과 값 범주**
  - `++i`(전위): **lvalue**를 돌려줌 → 다시 참조/대입 가능
  - `i++`(후위): **rvalue**(이전 값의 복사)를 돌려줌
- **top-level const vs low-level const**
  참조/포인터의 const는 “low-level const”(대상 불변), 객체 자체의 const는 “top-level const”.

---

## 평가 순서와 미지정 동작

“`int i = f1() * f2();` 에서 `f1`과 `f2` 중 무엇을 먼저 호출할지는 알 수 없다.”

→ C++ 표준은 많은 경우 피연산자 평가 순서를 정의하지 않는다(unspecified).

**컴파일러마다** 연산 결과가 달라질 수 있으며, 최적화를 위해 재배치될 수 있다.

**표준으로 정의하지 않은 이유**

→ 초창기 C언어 시절은 하드웨어와 컴파일러 기술이 다양했고, 이에 대응할 필요가 있었음

→ C++은 C와의 호환성을 중시했기 때문에 그대로 가져올 수 밖에 없었다.

컴파일러의 연산 순서를 자유롭게 재배치해서, 각자의 방식에 따라 레지스터 사용 최적화, 명령어 파이프라인 효율증가, 함수 호출 병렬화 등 각자의 방식대로 최적화된 성능을 구현했다.

순서를 보장해야 한다면, 그를 위한 수단(메모리 저장, 명령어 대기 등)이 필요해지기에 강제하지 않았다.

**권장**: 순서를 분명히 드러내라.

```cpp
int a = f1();
int b = f2();
int i = a * b;
```

```cpp
// 미정의 동작, 비권장
cout << i << " " << ++i << endl;

// 권장
cout << i << " ";
cout << ++i << endl;
```

`&&`, `||`, `?:`등의 ‘제어 흐름’ 연산자는, **평가 순서를 보장**한다.

&&나 || 의 동작 같은 경우엔 왼쪽 표현식을 먼저 평가하고, 조건에 맞지 않으면 오른쪽 표현식은 평가하지 않는다.

**주의, `operator&&`, `operator||`를 오버로드하면, 단락 평가가 사라진다.**

그러나 이를 오버로딩하면, 왼쪽과 오른쪽의 식을 모두 평가하는 방식으로 변한다.

```csharp
B operator&&(const B& a, const B& b) {           // 오버로드된 &&
    std::cout << "call &&\n";
    return { a.v && b.v };
}
```

이는 a && b가 오버로딩으로 인해 함수 호출로 변환되고, 인자로 넘기기 전에 a, b 표현식을 각각 평하기 때문이다.

---

## `bool`의 산술 사용 주의

“bool 값은 계산에 사용하면 안 된다. `-b`의 예시.”

`bool`은 정수 승격으로 `0` 또는 `1`이 된다.

```csharp
bool b = true;
bool b2 = -b;
```

b = true; 라는 문장에서 true가 int인 1로 승격된다.

따라서 -b는 -1을 의미하게 되고, -1은 true이므로, b2 또한 true가 된다.

---

## 상등(==)과 대입(=) 혼동

“`if (i = j)`는 `j`가 0이면 false, 아니면 true.”

오타로 인한 버그를 발생시킬 가능성이 있다.

---

## 간결한 식 읽기: `*pbeg++`

“간결함은 미덕이다. 익숙해지자.”

`*pbeg++`해석: `pbeg`가 가리키는 현재 원소를 참조한 뒤, `pbeg`를 다음으로 이동.

```cpp
cout << *pbeg << endl;
++pbeg
```

→ 의미를 정확히 알고 익숙해지면, **짧고 안전한 패턴**이 된다.

---

## 조건 연산자 `?:` (C#/C++ 공통 개념)

유니티에서 조건 연산자를 활용하면 가독성이 좋아질 때가 많다.

```csharp
captionDelay = (entry.metaDataKey == "long") ? 5f : 2f;
```

한 줄로 **분기와 값 선택**을 표현할 수 있다.

```csharp
private IEnumerator FadeImage(Image img, FadeOption opt, float duration) {
    float from = opt == FadeOption.In ? 0f : 1f;
    float to = opt == FadeOption.In ? 1f : 0f;

    yield return LerpUtil.Lerp(from, to, duration, a => {
        var c = img.color;
        c.a = a;
        img.color = c;
    });
}

// -------------

public static IEnumerator Lerp(float from, float to, float duration, Action<float> setter) {
    float elapsed = 0f;

    while (elapsed < duration) {
        elapsed += Time.deltaTime;
        float t = Mathf.Clamp01(elapsed / duration);
        setter(Mathf.Lerp(from, to, t));
        yield return null;
    }
    setter(to);
}
```

---

## 쉼표 연산자 `,`

왼쪽 표현식을 (**순서 보장하여**) 먼저 평가하고, 그 결과를 버린 뒤, 오른쪽 표현식을 평가하며 오른쪽의 값/값-범주를 결과로 돌려준다.

**동작 예시**

```cpp
int L() { std::cout << "L"; return 10; }
int R() { std::cout << "R"; return 20; }

int x = (L(), R());
// 출력: LR
// x는 20
```

**책의 예시**

```cpp
for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) {
		ivec[ix] = cnt;
}
```

```cpp
// 순서가 바뀌어도 결과는 동일함
for (vector<int>::size_type ix = 0; ix != ivec.size(); --cnt, ++ix) {
		ivec[ix] = cnt;
}
```

**순서 보장을 활용하기 위한 용도**

`for`의 세 번째 절에서 두 인자간의 결합이 존재하는 경우 등

```cpp
for (int i=0, j=0; i<10; ++i, j=i)  {
    // ...
}
```

단, 이를 과용하면 심각한 가독성 저하를 일으킬 수 있다

**주의**

1. 함수 인자 사이의 콤마는 “쉼표 연산자”가 아니다(단지 구분자) 순서 보장이 다르니 혼동 금지.
2. 우선순위가 매우 낮다. 괄호로 의도를 분명히 해라.

---

## 캐스트 요약: `static_cast`, `const_cast`, `reinterpret_cast`

### 1) `static_cast<T>(expr)`

**컴파일 타임에 검증 가능한, 의미 있는 변환**에 사용

수치형 사이 변환, 열거형↔수치, 포인터/참조의 **안전한 상향 캐스팅(업캐스트)** 등

사용자 정의 변환(명시적/암시적 생성자, 변환 함수)에도 관여

컴파일러가 이 변환이 언어적으로 의미가 있는지를 체크하기 때문에 비교적 안전하다.

**예시**

```cpp
double d = 3.14;
int    n = static_cast<int>(d); // 소수부 절단
```

### 2) `const_cast<T>(expr)`

const변환 전용 (주로 제거하는 방향)

**전제**: 원래 비-const로 만들어진 객체에 한해서만 수정이 사능하다.

원래 non-const로 만들어진 객체를 const 레퍼런스로 받았다” → cast로 풀고 수정 가능

처음부터 `const`로 생성된 객체를 풀고 수정 → 미정의 동작(UB)에 해당

UB는 오류를 발생시키지 않고, 일관된 동작을 보장하지 않기 때문에 더욱 위험하다.

**예시**

```cpp
void f(const std::string& s) {
    auto& m = const_cast<std::string&>(s);
    // s가 "원래 non-const"였다면 수정 가능,
    // "원래 const"였다면 수정은 UB
}
```

### 3) `reinterpret_cast<T>(expr)`

비트 패턴을 “다른 타입으로” 그대로 해석

포인터↔정수, 무관한 포인터 타입 간 변환 등 저수준 변환

**매우 이식성 낮고 위험**: 정렬/엄격 별칭(aliasing) 위반, 구현 정의 동작 가능

→ 플랫폼 종속 코드나 메모리 맵 장치 접근 같은 특수 상황 외 지양

수많은 UB를 발생시킬 가능성이 존재하는 매우 위험한 방식이다. 매우 엄격한 조건 하에서 다뤄야한다.

**예시**

```cpp
std::uintptr_t addr = reinterpret_cast<std::uintptr_t>(p);
void*          p2   = reinterpret_cast<void*>(addr);
```

권장 사항

“가능하면 **캐스트 자체를 줄여라**.”

피할 수 없다면 **순서: `static_cast` > `const_cast` > `reinterpret_cast`** (안전성 기준).

C스타일/함수형 캐스트는 **과하게 강력**하여 의도를 숨기니 지양해라.

---
