C++ 4장 정리: 표현식(Expressions)
1. 기본 개념: 연산자와 값의 종류
핵심:

단항/이항/삼항 연산자 존재. 같은 기호라도 문맥에 따라 의미가 달라짐(예: *는 역참조 또는 곱셈).

lvalue는 “메모리 위치”, rvalue는 “값”. 대입의 왼쪽은 수정 가능한 lvalue만 가능.

연산자 오버로딩으로 클래스 타입(string, vector 등)에 맞게 의미 재정의 가능.

자세한 설명:

lvalue 예: 변수 x, a[i], *p, 참조. rvalue 예: 10, x+y, 함수가 값으로 반환한 임시.

주소연산자(&)는 lvalue 필요, 결과는 rvalue(포인터 값).

역참조(*)/첨자([])/전위 증감(++i)은 lvalue를 돌려줌.

decltype에서 lvalue 표현식이면 참조 타입으로 추론됨.

2. 우선순위, 결합규칙, 평가 순서
핵심:

우선순위: 곱셈/나눗셈 > 덧셈/뺄셈.

결합규칙: 대부분 왼쪽 결합(왼→오).

평가 순서: 대부분 미정. &&, ||, ?:, ,(쉼표)만 좌→우 평가 보장(단락 평가 포함).

헷갈리면 괄호로 의도 명확화.

자세한 설명:

f()+g()*h()+j()에서 어떤 함수가 먼저 호출될지는 보장 없음.

한 표현식에서 같은 객체를 읽고-수정 동시에 하면 정의되지 않은 동작(UB). 예: cout << i << " " << ++i;

3. 산술 연산자
핵심:

+, -, *, /, %.

정수 나눗셈은 소수점 절삭. %는 정수 타입만.

오버플로/0으로 나누기 등은 정의되지 않은 동작.

자세한 설명:

작은 정수(bool/char/short)는 보통 int로 승격 후 계산.

부호 관련 규칙(C++11): 나눗셈은 0 쪽으로 절삭, m % n의 부호는 m과 같음.

4. 논리/관계 연산자
핵심:

!, <, <=, >, >=, ==, !=, &&, || → 결과는 bool.

&&, ||는 좌변 평가 후 필요할 때만 우변 평가(단락).

i < j < k 금지: (i < j)의 bool을 k와 비교하는 꼴이 됨. i < j && j < k로.

자세한 설명:

if (val)처럼 직접 조건으로 쓰는 게 가장 명확. true/false와 == 비교는 지양.

5. 대입/복합 대입
핵심:

=는 오른쪽 결합. a = b = 0; // b에 0 대입 후 그 결과를 a에 대입

우선순위 낮음: 조건 안에서 대입은 보통 괄호 필요.

복합 대입(+=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=)은 좌변 1회 평가로 안전/효율적.

자세한 설명:

if (i = j) 오타 주의: 의도는 if (i == j)일 가능성 높음.

초기화 리스트 대입은 클래스(vector 등)에서 의미가 정의됨.

6. 증가/감소 연산자
핵심:

전위(++i/--i): 변경된 값을 반환(lvalue).

후위(i++/i--): 원래 값을 반환(rvalue), 임시 저장이 필요.

필요 없으면 전위 습관화 권장.

자세한 설명:

*iter++는 “현재 요소를 사용하고 iter를 한 칸 이동”의 흔한 관용구. 후위의 우선순위가 높아 *(iter++)로 해석됨.

같은 표현식에서 피연산자를 변경하며 또 사용하는 패턴은 UB가 되기 쉬움.

7. 멤버 접근
핵심:

.은 객체, ->는 포인터. p->m는 (*p).m의 축약.

*의 우선순위가 .보다 낮으므로 (*p).m처럼 괄호 필요.

자세한 설명:

arrow/dot의 결과는 보통 lvalue(원본이 lvalue일 때).

8. 조건 연산자(?:)
핵심:

cond ? expr1 : expr2 한쪽만 평가. 우선순위 낮음 → 복합식에서는 괄호 권장.

중첩은 2~3단계 이내로. 가독성 우선.

자세한 설명:

출력식과 섞을 때 괄호 없으면 “1/0 출력” 같은 예상치 못한 결과가 나올 수 있음.

9. 비트 연산자
핵심:

~, <<, >>, &, ^, |

부호 비트 이슈로 unsigned 사용 권장.

입출력 연산자 <<, >>의 기본 의미는 시프트이며 좌결합.

자세한 설명:

시프트의 우변은 음수 불가, 결과 비트수보다 작아야 함. 서명 있는 피연산자의 오른쪽 시프트는 구현 정의.

플래그 비트 마스크 패턴: set |= (1u<<n), clear &= ~(1u<<n), test = (x & (1u<<n)).

10. sizeof
핵심:

타입/표현식의 바이트 크기(size_t, 상수식). 피연산자 평가 안 함.

배열에 쓰면 전체 크기. 요소 크기로 나눠 길이 계산 가능.

자세한 설명:

sizeof *p는 안전: p가 무효여도 타입 정보만 사용.

string/vector의 sizeof는 고정부 크기만, 내부 요소 저장 공간은 포함 안 함.

11. 쉼표 연산자
핵심:

좌→우 순서로 평가, 좌측 결과 폐기, 우측 값이 전체 결과.

for 헤더에서 다중 갱신에 주로 사용.

자세한 설명:

결과가 lvalue가 되려면 오른쪽 피연산자가 lvalue여야 함.

12. 타입 변환
핵심:

암시적 변환: 작은 정수 승격, 조건의 bool 변환, 혼합 타입의 공통 타입 변환, 초기화/대입 시 좌변 타입으로 변환.

명시적 변환(캐스트):

static_cast: 일반적이고 비교적 안전한 변환(정수→실수, void* 복구 등).

const_cast: 저수준 const 제거/부여(주의: 진짜 const를 수정하면 UB).

reinterpret_cast: 비트 재해석, 매우 위험·플랫폼 의존.

dynamic_cast: 상속 계층의 안전 다운캐스트(후반부에서 학습).

원칙: 캐스트는 가급적 피하고, 필요한 경우 의도를 드러내며 범위를 최소화.

자세한 설명:

배열은 대부분의 식에서 첫 원소 포인터로 decay. 예외: sizeof, decltype, &, typeid, 배열 참조 초기화.

0/nullptr은 어떤 포인터 타입으로도 변환 가능. T* → void*, T& → const T&는 가능하지만 반대는 불가.

13. 핵심 원칙들
13-1. 안전성 원칙
같은 표현식에서 “변경”과 “재사용”을 함께 하지 말기:

예: a[i] = a[++i];, cout << i << ++i; → 정의되지 않은 동작.

조건/단락 평가 활용:

ptr && *ptr 사용처럼 좌변으로 안전성 보장 후 우변 평가.

13-2. 성능과 효율성
전위 증감 습관:

특히 반복자 타입에서 불필요한 복사/임시를 피함.

복합 대입 사용:

좌변 1회 평가로 반복자/복잡한 표현식에서 더 안전하고 종종 효율적.

13-3. 문법과 관례
괄호로 의도 고정:

우선순위/결합/출력식 혼합 시 반드시 괄호로 원하는 그룹화.

비교 체이닝 금지:

i < j < k 대신 i < j && j < k.

13-4. 보안과 안정성
비트/시프트는 unsigned로:

서명 비트 관련 UB/구현 정의 회피.

캐스트 최소화:

reinterpret_cast 금지 수준으로 자제. 필요한 경우 주석으로 가정/의도 명시.
